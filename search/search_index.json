{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"R-Type Documentation The R-Type project aims at developing a clone of the classic side-scrolling shoot 'em up arcade game called \"R-Type.\" The project involves creating a server that will run the game, and a client that will be able to display the game. This version of R-Type is multiplayer and the game is developed using a custom engine of our own called Haze. Prerequisites Before you begin, ensure you have met the following requirements: - SFML - Asio Getting Started To install and launch R-Type, follow these steps: Clone the github project git clone https://github.com/votre-utilisateur/haze-engine.git Create the build directory cmake -S . -B build Compile the project cmake --build build Execute the binaries Server: ./build/r-type-server Client: ./build/r-type-client Doc [[How to use]] [[Protocol/Protocol]]","title":"R-Type Documentation"},{"location":"#r-type-documentation","text":"The R-Type project aims at developing a clone of the classic side-scrolling shoot 'em up arcade game called \"R-Type.\" The project involves creating a server that will run the game, and a client that will be able to display the game. This version of R-Type is multiplayer and the game is developed using a custom engine of our own called Haze.","title":"R-Type Documentation"},{"location":"#prerequisites","text":"Before you begin, ensure you have met the following requirements: - SFML - Asio","title":"Prerequisites"},{"location":"#getting-started","text":"To install and launch R-Type, follow these steps: Clone the github project git clone https://github.com/votre-utilisateur/haze-engine.git Create the build directory cmake -S . -B build Compile the project cmake --build build Execute the binaries Server: ./build/r-type-server Client: ./build/r-type-client","title":"Getting Started"},{"location":"#doc","text":"[[How to use]] [[Protocol/Protocol]]","title":"Doc"},{"location":"Haze/ComponentArray/","text":"What is a ComponentArray The component array in Haze is where is stored all of the data of the engine. It contains all of the components in a two dimensional sparse array. Each entity being a simple id in this array. (for more details about entity: Entity ) Each column in the component array being an entity and each line a component. If an Entity doesn't posses a component this field will simply be null . If this entity have this component, it will contain the pointer to it.","title":"What is a ComponentArray"},{"location":"Haze/ComponentArray/#what-is-a-componentarray","text":"The component array in Haze is where is stored all of the data of the engine. It contains all of the components in a two dimensional sparse array. Each entity being a simple id in this array. (for more details about entity: Entity ) Each column in the component array being an entity and each line a component. If an Entity doesn't posses a component this field will simply be null . If this entity have this component, it will contain the pointer to it.","title":"What is a ComponentArray"},{"location":"Haze/ComponentCore%20Technical/","text":"Component core: #include \"inputs.hpp\" namespace Haze { class Component; struct Position; struct Scale; struct Velocity; struct Move; struct Health; struct Damage; struct Collision; struct Hitbox; struct LifeTime; struct OnKeyPressed; struct OnKeyReleased; struct OnMousePressed; struct OnMouseReleased; struct Hide; } struct Position : public Component { Position(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Position\"; } void show() const override { std::cout << \"Position: \" << x << \", \" << y << std::endl; } }; Position is used to set the position of the entity struct Scale : public Component { Scale(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Scale\"; } void show() const override { std::cout << \"Scale: \" << x << \", \" << y << std::endl; } }; Scale sets the scale of the entity. This is applied to the Hitbox struct Velocity : public Component { Velocity(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Velocity\"; } void show() const override { std::cout << \"Velocity: \" << x << \", \" << y << std::endl; } }; Velocity is the movement applied to the entity every frame struct Move : public Component { Move(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Move\"; } void show() const override { std::cout << \"Move: \" << x << \", \" << y << std::endl; } }; Move is a movement applied only once to the entity, it is automatically destroyed after use struct Health : public Component { Health(int health) : health(health) {} int health; std::string getType() const override { return \"Health\"; } void show() const override { std::cout << \"Health: \" << health << std::endl; } }; Health can be use to setup the health of an entity struct Damage : public Component { Damage(int damage) : damage(damage) {} int damage; std::string getType() const override { return \"Damage\"; } void show() const override { std::cout << \"Damage: \" << damage << std::endl; } }; Damage can be used to setup the damage of an entity struct Collision : public Component { enum CollisionType { NONE = 0, LAMBDA = 1, WALL = 2, }; struct CollisionInfo { CollisionType type; double tics; std::function<void(int, int)> onCollision = [](int i, int j) {}; std::chrono::time_point<std::chrono::high_resolution_clock> lastCollision = std::chrono::high_resolution_clock::now(); }; Collision(std::string scene, std::map<std::string, CollisionInfo> behavior) : scene(scene), behavior(behavior) {} std::string scene; std::map<std::string, CollisionInfo> behavior; std::string getType() const override { return \"Collision\"; } void show() const override { std::cout << \"Collision: \" << scene << std::endl; } }; Collision is the component that will define the collision behavior of an entity. It takes : - a scene that will be use as an identification tag for a group of entity - and a map of behavior that will define what happens on collision between two entity of certain scene. struct Hitbox : public Component { struct intRect { int x; int y; int width; int height; }; Hitbox(std::vector<intRect> hitbox) : hitbox(hitbox) {} std::vector<intRect> hitbox; std::string getType() const override { return \"Hitbox\"; } void show() const override { std::cout << \"Hitbox: \" << std::endl; } }; Hitbox is used to set the hitbox of an entity it is defined as a vector of intRect which allows to have a hitbox composed of multiples rectangles. struct LifeTime : public Component { LifeTime(int lifeTime) : lifeTime(lifeTime) {} int lifeTime; int tics = 0; std::string getType() const override { return \"LifeTime\"; } void show() const override { std::cout << \"LifeTime: \" << lifeTime << std::endl; } }; LifeTime can be used to set a lifetime limit for an entity This lifetime is expressed in tics. struct OnKeyPressed : public Component { OnKeyPressed(std::function<void(int, std::vector<InputType>)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int, std::vector<InputType>)> callback; size_t player; std::string getType() const override {return \"OnKeyPressed\";} void show() const override { std::cout << \"OnKeyPressed\" << std::endl; } }; OnKeyPressed can be used to set a callback to execute, with as an argument every simultaneous key pressed in the engine. The size_t player is the id of the inputs. The engine can have multiple list of inputs if used as a server. struct OnKeyReleased : public Component { OnKeyReleased(std::function<void(int, std::vector<InputType>)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int, std::vector<InputType>)> callback; size_t player; std::string getType() const override{return \"OnKeyReleased\";} void show() const override { std::cout << \"OnKeyReleased\" << std::endl; } }; OnKeyReleased can be used to set a callback to execute, with as an argument every simultaneous key released in the engine. The size_t player is the id of the inputs. The engine can have multiple list of inputs if used as a server. struct OnMousePressed : public Component { OnMousePressed(std::function<void(int)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int)> callback; size_t player; std::string getType() const override{return \"OnMousePressed\";} void show() const override { std::cout << \"OnMousePressed\" << std::endl; } }; OnMousePressed can be used to set a callback to execute every time the mouse is pressed and is intersecting the hitbox of the entity. The size_t player is the id of the inputs. The engine can have multiple list of inputs if used as a server. struct OnMouseReleased : public Component { OnMouseReleased(std::function<void(int)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int)> callback; size_t player; std::string getType() const override{return \"OnMouseReleased\";} void show() const override { std::cout << \"OnMouseReleased\" << std::endl; } }; OnMouseReleased can be used to set a callback to execute every time the mouse is released and is intersecting the hitbox of the entity. The size_t player is the id of the inputs. The engine can have multiple list of inputs if used as a server. struct Hide : public Component { Hide() {} std::string getType() const override { return \"Hide\"; } void show() const override { std::cout << \"Hide\" << std::endl; } }; Hide is used to disable an entity. When in this state, the entity in not displayed nor can receive inputs or move.","title":"ComponentCore Technical"},{"location":"Haze/ComponentCore%20Technical/#component-core","text":"#include \"inputs.hpp\" namespace Haze { class Component; struct Position; struct Scale; struct Velocity; struct Move; struct Health; struct Damage; struct Collision; struct Hitbox; struct LifeTime; struct OnKeyPressed; struct OnKeyReleased; struct OnMousePressed; struct OnMouseReleased; struct Hide; } struct Position : public Component { Position(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Position\"; } void show() const override { std::cout << \"Position: \" << x << \", \" << y << std::endl; } }; Position is used to set the position of the entity struct Scale : public Component { Scale(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Scale\"; } void show() const override { std::cout << \"Scale: \" << x << \", \" << y << std::endl; } }; Scale sets the scale of the entity. This is applied to the Hitbox struct Velocity : public Component { Velocity(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Velocity\"; } void show() const override { std::cout << \"Velocity: \" << x << \", \" << y << std::endl; } }; Velocity is the movement applied to the entity every frame struct Move : public Component { Move(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Move\"; } void show() const override { std::cout << \"Move: \" << x << \", \" << y << std::endl; } }; Move is a movement applied only once to the entity, it is automatically destroyed after use struct Health : public Component { Health(int health) : health(health) {} int health; std::string getType() const override { return \"Health\"; } void show() const override { std::cout << \"Health: \" << health << std::endl; } }; Health can be use to setup the health of an entity struct Damage : public Component { Damage(int damage) : damage(damage) {} int damage; std::string getType() const override { return \"Damage\"; } void show() const override { std::cout << \"Damage: \" << damage << std::endl; } }; Damage can be used to setup the damage of an entity struct Collision : public Component { enum CollisionType { NONE = 0, LAMBDA = 1, WALL = 2, }; struct CollisionInfo { CollisionType type; double tics; std::function<void(int, int)> onCollision = [](int i, int j) {}; std::chrono::time_point<std::chrono::high_resolution_clock> lastCollision = std::chrono::high_resolution_clock::now(); }; Collision(std::string scene, std::map<std::string, CollisionInfo> behavior) : scene(scene), behavior(behavior) {} std::string scene; std::map<std::string, CollisionInfo> behavior; std::string getType() const override { return \"Collision\"; } void show() const override { std::cout << \"Collision: \" << scene << std::endl; } }; Collision is the component that will define the collision behavior of an entity. It takes : - a scene that will be use as an identification tag for a group of entity - and a map of behavior that will define what happens on collision between two entity of certain scene. struct Hitbox : public Component { struct intRect { int x; int y; int width; int height; }; Hitbox(std::vector<intRect> hitbox) : hitbox(hitbox) {} std::vector<intRect> hitbox; std::string getType() const override { return \"Hitbox\"; } void show() const override { std::cout << \"Hitbox: \" << std::endl; } }; Hitbox is used to set the hitbox of an entity it is defined as a vector of intRect which allows to have a hitbox composed of multiples rectangles. struct LifeTime : public Component { LifeTime(int lifeTime) : lifeTime(lifeTime) {} int lifeTime; int tics = 0; std::string getType() const override { return \"LifeTime\"; } void show() const override { std::cout << \"LifeTime: \" << lifeTime << std::endl; } }; LifeTime can be used to set a lifetime limit for an entity This lifetime is expressed in tics. struct OnKeyPressed : public Component { OnKeyPressed(std::function<void(int, std::vector<InputType>)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int, std::vector<InputType>)> callback; size_t player; std::string getType() const override {return \"OnKeyPressed\";} void show() const override { std::cout << \"OnKeyPressed\" << std::endl; } }; OnKeyPressed can be used to set a callback to execute, with as an argument every simultaneous key pressed in the engine. The size_t player is the id of the inputs. The engine can have multiple list of inputs if used as a server. struct OnKeyReleased : public Component { OnKeyReleased(std::function<void(int, std::vector<InputType>)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int, std::vector<InputType>)> callback; size_t player; std::string getType() const override{return \"OnKeyReleased\";} void show() const override { std::cout << \"OnKeyReleased\" << std::endl; } }; OnKeyReleased can be used to set a callback to execute, with as an argument every simultaneous key released in the engine. The size_t player is the id of the inputs. The engine can have multiple list of inputs if used as a server. struct OnMousePressed : public Component { OnMousePressed(std::function<void(int)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int)> callback; size_t player; std::string getType() const override{return \"OnMousePressed\";} void show() const override { std::cout << \"OnMousePressed\" << std::endl; } }; OnMousePressed can be used to set a callback to execute every time the mouse is pressed and is intersecting the hitbox of the entity. The size_t player is the id of the inputs. The engine can have multiple list of inputs if used as a server. struct OnMouseReleased : public Component { OnMouseReleased(std::function<void(int)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int)> callback; size_t player; std::string getType() const override{return \"OnMouseReleased\";} void show() const override { std::cout << \"OnMouseReleased\" << std::endl; } }; OnMouseReleased can be used to set a callback to execute every time the mouse is released and is intersecting the hitbox of the entity. The size_t player is the id of the inputs. The engine can have multiple list of inputs if used as a server. struct Hide : public Component { Hide() {} std::string getType() const override { return \"Hide\"; } void show() const override { std::cout << \"Hide\" << std::endl; } }; Hide is used to disable an entity. When in this state, the entity in not displayed nor can receive inputs or move.","title":"Component core:"},{"location":"Haze/ComponentGfx%20Technical/","text":"Component graphics: #include \"Component.hpp\" #include \"inputs.hpp\" namespace Haze { struct Sprite; struct Animation; struct Window; struct HitboxDisplay; struct Text; } struct Sprite : public Component { Sprite(std::string path) : path(path) { std::cout << \"path \" << path << std::endl; texture.loadFromFile(path); sprite.setTexture(texture); } std::string path; sf::Sprite sprite; sf::Texture texture; std::string getType() const override{return \"Sprite\";} void show() const override { std::cout << \"flm\" << path << std::endl; } }; Sprite is used to set a sprite with a texture to an entity. It just takes a path for the texture. struct Animation : public Component { enum AnimationType { LOOP, BOOMERANG, ONCE }; struct intRect { int x; int y; int width; int height; }; Animation(std::vector<intRect> frames, AnimationType type, bool direction, double tics) : frames(frames), type(type), tics(tics), direction(direction) {} std::vector<intRect> frames; AnimationType type = AnimationType::LOOP; double tics; size_t currentFrame = 0; bool direction = true; std::chrono::time_point<std::chrono::high_resolution_clock> lastAnimation = std::chrono::high_resolution_clock::now(); std::string getType() const override { return \"Animation\"; } void show() const override { std::cout << \"Animation: \" << std::endl; } }; Animation is the component that will define how a sprite is animated. It takes: - a vector of IntRect that will define the position and the size of every frame of the animation - an AnimationType that will define id the animation is a LOOP , a BOOMERANG or simply a static image (note that you can still have multiple frames and change by hand the currentFrame ) - a direction that will define the direction of the animation ( 1 for left to right and 2 for right to left). - and a tics that will set the time between the updates of the animation. struct Window : public Component { Window(int width, int height) : width(width), height(height) { window.create(sf::VideoMode(width, height), \"R-Type\"); window.setFramerateLimit(60); window.setKeyRepeatEnabled(true); view.reset(sf::FloatRect(0, 0, width, height)); view.setViewport(sf::FloatRect(0, 0, 1.0f, 1.0f)); window.setView(view); } int width; int height; sf::RenderWindow window; sf::View view; sf::Event event; std::string getType() const override{return \"Window\";} void show() const override { std::cout << \"Window: \" << width << \", \" << height << std::endl; } }; Window is the component that can set the window for your game. A strong advice is that the entity who has the component window doesn't have any other component. struct HitboxDisplay : public Component { HitboxDisplay() { rect.setFillColor(sf::Color::Transparent); rect.setOutlineColor(sf::Color::Red); rect.setOutlineThickness(5); } sf::Color color = sf::Color::Red; sf::RectangleShape rect; std::string getType() const override{return \"HitboxDisplay\";} void show() const override { std::cout << \"HitboxDisplay: \" << std::endl; } }; HitboxDisplay is a debug tool to see the Hitbox of your entity struct Text : public Component { Text(const std::string &text, sf::Color color, const std::string &fontname = \"arial.ttf\") : text(text), color(color) { font.loadFromFile(\"../assets/fonts/\" + fontname); textObj.setFont(font); textObj.setString(text); textObj.setFillColor(color); } std::string text; sf::Color color; sf::Font font; sf::Text textObj; std::string getType() const override {return \"Text\";} void show() const override { std::cout << \"Text: \" << text << std::endl; } }; Text is used to create a text component to your entity. It takes: - the text you want to display - a color - and a font name","title":"ComponentGfx Technical"},{"location":"Haze/ComponentGfx%20Technical/#component-graphics","text":"#include \"Component.hpp\" #include \"inputs.hpp\" namespace Haze { struct Sprite; struct Animation; struct Window; struct HitboxDisplay; struct Text; } struct Sprite : public Component { Sprite(std::string path) : path(path) { std::cout << \"path \" << path << std::endl; texture.loadFromFile(path); sprite.setTexture(texture); } std::string path; sf::Sprite sprite; sf::Texture texture; std::string getType() const override{return \"Sprite\";} void show() const override { std::cout << \"flm\" << path << std::endl; } }; Sprite is used to set a sprite with a texture to an entity. It just takes a path for the texture. struct Animation : public Component { enum AnimationType { LOOP, BOOMERANG, ONCE }; struct intRect { int x; int y; int width; int height; }; Animation(std::vector<intRect> frames, AnimationType type, bool direction, double tics) : frames(frames), type(type), tics(tics), direction(direction) {} std::vector<intRect> frames; AnimationType type = AnimationType::LOOP; double tics; size_t currentFrame = 0; bool direction = true; std::chrono::time_point<std::chrono::high_resolution_clock> lastAnimation = std::chrono::high_resolution_clock::now(); std::string getType() const override { return \"Animation\"; } void show() const override { std::cout << \"Animation: \" << std::endl; } }; Animation is the component that will define how a sprite is animated. It takes: - a vector of IntRect that will define the position and the size of every frame of the animation - an AnimationType that will define id the animation is a LOOP , a BOOMERANG or simply a static image (note that you can still have multiple frames and change by hand the currentFrame ) - a direction that will define the direction of the animation ( 1 for left to right and 2 for right to left). - and a tics that will set the time between the updates of the animation. struct Window : public Component { Window(int width, int height) : width(width), height(height) { window.create(sf::VideoMode(width, height), \"R-Type\"); window.setFramerateLimit(60); window.setKeyRepeatEnabled(true); view.reset(sf::FloatRect(0, 0, width, height)); view.setViewport(sf::FloatRect(0, 0, 1.0f, 1.0f)); window.setView(view); } int width; int height; sf::RenderWindow window; sf::View view; sf::Event event; std::string getType() const override{return \"Window\";} void show() const override { std::cout << \"Window: \" << width << \", \" << height << std::endl; } }; Window is the component that can set the window for your game. A strong advice is that the entity who has the component window doesn't have any other component. struct HitboxDisplay : public Component { HitboxDisplay() { rect.setFillColor(sf::Color::Transparent); rect.setOutlineColor(sf::Color::Red); rect.setOutlineThickness(5); } sf::Color color = sf::Color::Red; sf::RectangleShape rect; std::string getType() const override{return \"HitboxDisplay\";} void show() const override { std::cout << \"HitboxDisplay: \" << std::endl; } }; HitboxDisplay is a debug tool to see the Hitbox of your entity struct Text : public Component { Text(const std::string &text, sf::Color color, const std::string &fontname = \"arial.ttf\") : text(text), color(color) { font.loadFromFile(\"../assets/fonts/\" + fontname); textObj.setFont(font); textObj.setString(text); textObj.setFillColor(color); } std::string text; sf::Color color; sf::Font font; sf::Text textObj; std::string getType() const override {return \"Text\";} void show() const override { std::cout << \"Text: \" << text << std::endl; } }; Text is used to create a text component to your entity. It takes: - the text you want to display - a color - and a font name","title":"Component graphics:"},{"location":"Haze/ECS/","text":"Understanding the Entity-Component-System (ECS) Architecture The Entity-Component-System (ECS) architecture is a design pattern commonly used in game development and simulation systems. It separates the game logic into three distinct parts: entities, components, and systems. This separation promotes modularity, flexibility, and performance in managing complex systems. Components Components are the building blocks of an ECS. They are small, reusable pieces of data that define the attributes or behaviors of an entity. Each component typically contains only the necessary data and functions required for a specific aspect of the entity. For example, in a game, you might have components like: Position : Contains position of the entity Sprite : Contains information about the entity's visual representation. Scale : Stores information about the entity's scale Components are often represented as simple data structures and do not contain logic or methods. For more information about components in Haze: ComponentsGfx ComponentsCore Entities Entities are the game objects themselves. An entity is essentially a container that groups together one or more components. Entities don't have behavior on their own but gain behavior by having the appropriate components attached. For example, a player character entity might consist of a Position , a Sprite , and an Input . Entities are typically identified by a unique ID or a name to make them easy to reference. Systems Systems are responsible for updating and processing entities and their components. Each system has a specific role, such as rendering, physics simulation, or input handling. Systems iterate over the entities that contain the necessary components they are designed to operate on. For example: The RenderSystem processes entities with SpriteComponent to render them on the screen. The PhysicsSystem handles entities with PhysicsComponent to simulate physics interactions. The InputSystem listens for input events and updates entities with InputComponent . Systems are crucial for managing the flow of game logic and keeping it organized. Benefits of ECS Modularity : Components and systems can be added or removed without affecting the rest of the system. Performance : Data locality and cache-friendliness are often optimized in ECS, leading to efficient processing. Scalability : ECS scales well for large and complex systems. Code Reusability : Components are highly reusable, reducing redundant code.","title":"Understanding the Entity-Component-System (ECS) Architecture"},{"location":"Haze/ECS/#understanding-the-entity-component-system-ecs-architecture","text":"The Entity-Component-System (ECS) architecture is a design pattern commonly used in game development and simulation systems. It separates the game logic into three distinct parts: entities, components, and systems. This separation promotes modularity, flexibility, and performance in managing complex systems.","title":"Understanding the Entity-Component-System (ECS) Architecture"},{"location":"Haze/ECS/#components","text":"Components are the building blocks of an ECS. They are small, reusable pieces of data that define the attributes or behaviors of an entity. Each component typically contains only the necessary data and functions required for a specific aspect of the entity. For example, in a game, you might have components like: Position : Contains position of the entity Sprite : Contains information about the entity's visual representation. Scale : Stores information about the entity's scale Components are often represented as simple data structures and do not contain logic or methods. For more information about components in Haze: ComponentsGfx ComponentsCore","title":"Components"},{"location":"Haze/ECS/#entities","text":"Entities are the game objects themselves. An entity is essentially a container that groups together one or more components. Entities don't have behavior on their own but gain behavior by having the appropriate components attached. For example, a player character entity might consist of a Position , a Sprite , and an Input . Entities are typically identified by a unique ID or a name to make them easy to reference.","title":"Entities"},{"location":"Haze/ECS/#systems","text":"Systems are responsible for updating and processing entities and their components. Each system has a specific role, such as rendering, physics simulation, or input handling. Systems iterate over the entities that contain the necessary components they are designed to operate on. For example: The RenderSystem processes entities with SpriteComponent to render them on the screen. The PhysicsSystem handles entities with PhysicsComponent to simulate physics interactions. The InputSystem listens for input events and updates entities with InputComponent . Systems are crucial for managing the flow of game logic and keeping it organized.","title":"Systems"},{"location":"Haze/ECS/#benefits-of-ecs","text":"Modularity : Components and systems can be added or removed without affecting the rest of the system. Performance : Data locality and cache-friendliness are often optimized in ECS, leading to efficient processing. Scalability : ECS scales well for large and complex systems. Code Reusability : Components are highly reusable, reducing redundant code.","title":"Benefits of ECS"},{"location":"Haze/Engine%20Technical/","text":"Name Haze::Engine - a the main engine class. Synopsis #include \"Entity.hpp\" #include \"ComponentList.hpp\" #include \"IPipeline.hpp\" #include \"protocol.hpp\" namespace Haze { class Engine { public: Engine(); ~Engine(); void init(); void update(); Entity *createEntity(); Entity *getEntity(size_t id); void removeEntity(size_t id); void removeEntity(Entity *entity); bool isOpen(); void setInfoInputs(info_inputs info, size_t id); ComponentList *getComponentList(); std::vector<info_inputs> *getInfoInputs(); private: std::vector<std::unique_ptr<Entity>> _entities; std::vector<std::unique_ptr<IPipeline>> _pipelines; ComponentList *_componentList; std::vector<info_inputs> _infoInputs; }; } Description The purpose of the Engine class is to encapsulate the entire Haze ecosystem so it can be easily used and extended. Methods void init(); init is used just after the creation of the engine and and is used to setup everything in the class void update(); update is used to compute one tic of the game. It launches every [[Pipeline]] in the engine Entity *createEntity(); createEntity is used to add an entity to the engine Entity *getEntity(size_t id); getEntity is used to get an entity from the engine. Returns nullptr if the entity doesn't exits. void removeEntity(size_t id); void removeEntity(Entity *entity); removeEntity deletes an entity from the engine bool isOpen(); isOpen tells if the engine is still running void setInfoInputs(info_inputs info, size_t id); setInfoInputs is used to simulate input into the engine. Useful if the engine is running without haze-graphics in a server. It takes an info_inputs defined at [[Protocol]] and an id which is the number of the player how has sent this input. [!warning] Here id 0 is where is stored the global inputs. It is filled automatically by the pullEvent system from haze-graphics If you are not taking inputs from other players you should not use this method. ComponentList *getComponentList(); getComponentList gives the ComponentList of the program (mainly internal use) * std::vector<info_inputs> *getInfoInputs(); getInfoInputs gives the list of all of the inputs registered in the engine (mainly internal use) *","title":"Engine Technical"},{"location":"Haze/Engine%20Technical/#name","text":"Haze::Engine - a the main engine class.","title":"Name"},{"location":"Haze/Engine%20Technical/#synopsis","text":"#include \"Entity.hpp\" #include \"ComponentList.hpp\" #include \"IPipeline.hpp\" #include \"protocol.hpp\" namespace Haze { class Engine { public: Engine(); ~Engine(); void init(); void update(); Entity *createEntity(); Entity *getEntity(size_t id); void removeEntity(size_t id); void removeEntity(Entity *entity); bool isOpen(); void setInfoInputs(info_inputs info, size_t id); ComponentList *getComponentList(); std::vector<info_inputs> *getInfoInputs(); private: std::vector<std::unique_ptr<Entity>> _entities; std::vector<std::unique_ptr<IPipeline>> _pipelines; ComponentList *_componentList; std::vector<info_inputs> _infoInputs; }; }","title":"Synopsis"},{"location":"Haze/Engine%20Technical/#description","text":"The purpose of the Engine class is to encapsulate the entire Haze ecosystem so it can be easily used and extended.","title":"Description"},{"location":"Haze/Engine%20Technical/#methods","text":"void init(); init is used just after the creation of the engine and and is used to setup everything in the class void update(); update is used to compute one tic of the game. It launches every [[Pipeline]] in the engine Entity *createEntity(); createEntity is used to add an entity to the engine Entity *getEntity(size_t id); getEntity is used to get an entity from the engine. Returns nullptr if the entity doesn't exits. void removeEntity(size_t id); void removeEntity(Entity *entity); removeEntity deletes an entity from the engine bool isOpen(); isOpen tells if the engine is still running void setInfoInputs(info_inputs info, size_t id); setInfoInputs is used to simulate input into the engine. Useful if the engine is running without haze-graphics in a server. It takes an info_inputs defined at [[Protocol]] and an id which is the number of the player how has sent this input. [!warning] Here id 0 is where is stored the global inputs. It is filled automatically by the pullEvent system from haze-graphics If you are not taking inputs from other players you should not use this method. ComponentList *getComponentList(); getComponentList gives the ComponentList of the program (mainly internal use) * std::vector<info_inputs> *getInfoInputs(); getInfoInputs gives the list of all of the inputs registered in the engine (mainly internal use) *","title":"Methods"},{"location":"Haze/Entity%20Technical/","text":"Name Haze::Core - a class representing the entities used in the haze engine. Synopsis #include \"Component.hpp\" namespace Haze { class Entity { public: Entity(ComponentList *componentList, size_t _id); ~Entity(); void addComponent(Component *component); void removeComponent(std::string type); Component *getComponent(std::string type); size_t getId() const { return _id; }; private: size_t _id; ComponentList *_componentList; }; } Description The purpose of the Entity class is to allow the user of Haze to manipulate the components of the system. The concept of Entity in Haze is only an id that points toward a list of components Methods void addComponent(Component *component); addComponent is used to add a component to an entity void removeComponent(std::string type); removeComponent is used to remove a component from an entity Component *getComponent(std::string type); getComponent is used to get and modify a component of an entity size_t getId() const { return _id; }; getId is used to get the id of an entity","title":"Entity Technical"},{"location":"Haze/Entity%20Technical/#name","text":"Haze::Core - a class representing the entities used in the haze engine.","title":"Name"},{"location":"Haze/Entity%20Technical/#synopsis","text":"#include \"Component.hpp\" namespace Haze { class Entity { public: Entity(ComponentList *componentList, size_t _id); ~Entity(); void addComponent(Component *component); void removeComponent(std::string type); Component *getComponent(std::string type); size_t getId() const { return _id; }; private: size_t _id; ComponentList *_componentList; }; }","title":"Synopsis"},{"location":"Haze/Entity%20Technical/#description","text":"The purpose of the Entity class is to allow the user of Haze to manipulate the components of the system. The concept of Entity in Haze is only an id that points toward a list of components","title":"Description"},{"location":"Haze/Entity%20Technical/#methods","text":"void addComponent(Component *component); addComponent is used to add a component to an entity void removeComponent(std::string type); removeComponent is used to remove a component from an entity Component *getComponent(std::string type); getComponent is used to get and modify a component of an entity size_t getId() const { return _id; }; getId is used to get the id of an entity","title":"Methods"},{"location":"Haze/Getting%20Started/","text":"Haze ECS The Haze engine is a pure ECS with some little tweaks and additions. An ECS architecture has many benefits for a game engine and that is why we chose to use it (benefits described at ECS ) Architecture This is the full architecture of Haze . As you can see we have the basics of an ECS such as Components, Entity and Systems. If you want the technical documentation of these parts of Haze you can learn more at ComponentsGfx , ComponentsCore , Entities and Systems . Pipelines We have also added Pipelines that allows to group systems hence allowing to differentiate easily systems that need additional libraries such as SFML from others that don't need it. Graphic Encapsulation Graphic encapsulation is also something that we have decided make in our engine. This addition makes it easy to change the graphic library of Haze. ComponentArray and Entity Finally that entirety of the components of the engine is stored in a sigle class ComponentArray which make the iteration of the component much faster and easier. Entities are just handlers for the ComponentArray. Library Haze is a currently composed of two different static libraries which are: haze-core to include with #include <haze-core.hpp> This library gather everything related to basic engine working such as positions , velocity or collisions . This part of Haze doesn't require any external library to be functional and can be imported in a server . haze-graphic to include with #include <haze-graphic.hpp> This library gather everything related to the graphic part of the engine such as displaying, getting inputs or playing audio . This part of Haze require the use of SFML to be functional and cannot be imported in a server nor any system with no SFML install .","title":"Haze"},{"location":"Haze/Getting%20Started/#haze","text":"","title":"Haze"},{"location":"Haze/Getting%20Started/#ecs","text":"The Haze engine is a pure ECS with some little tweaks and additions. An ECS architecture has many benefits for a game engine and that is why we chose to use it (benefits described at ECS )","title":"ECS"},{"location":"Haze/Getting%20Started/#architecture","text":"This is the full architecture of Haze . As you can see we have the basics of an ECS such as Components, Entity and Systems. If you want the technical documentation of these parts of Haze you can learn more at ComponentsGfx , ComponentsCore , Entities and Systems .","title":"Architecture"},{"location":"Haze/Getting%20Started/#pipelines","text":"We have also added Pipelines that allows to group systems hence allowing to differentiate easily systems that need additional libraries such as SFML from others that don't need it.","title":"Pipelines"},{"location":"Haze/Getting%20Started/#graphic-encapsulation","text":"Graphic encapsulation is also something that we have decided make in our engine. This addition makes it easy to change the graphic library of Haze.","title":"Graphic Encapsulation"},{"location":"Haze/Getting%20Started/#componentarray-and-entity","text":"Finally that entirety of the components of the engine is stored in a sigle class ComponentArray which make the iteration of the component much faster and easier. Entities are just handlers for the ComponentArray.","title":"ComponentArray and Entity"},{"location":"Haze/Getting%20Started/#library","text":"Haze is a currently composed of two different static libraries which are:","title":"Library"},{"location":"Haze/Getting%20Started/#haze-core","text":"to include with #include <haze-core.hpp> This library gather everything related to basic engine working such as positions , velocity or collisions . This part of Haze doesn't require any external library to be functional and can be imported in a server .","title":"haze-core"},{"location":"Haze/Getting%20Started/#haze-graphic","text":"to include with #include <haze-graphic.hpp> This library gather everything related to the graphic part of the engine such as displaying, getting inputs or playing audio . This part of Haze require the use of SFML to be functional and cannot be imported in a server nor any system with no SFML install .","title":"haze-graphic"},{"location":"Haze/Graphic_encapsulation/","text":"How does the graphic encapsulation work in Haze ? The graphic encapsulation exists to allows to change easily the graphic library of the engine. Multiples virtual class exits in this encapsulation those are: - ISprite - ITexture - IText - IAudio - IWindow - IInput - IRect - IColor Each of these class needs to be inherited to allows for full support of a graphic lib. For now Haze support SFML with - SfSprite - SfTexture - SfText - SfAudio - SfWindow - SfInput - SfRect - SfColor","title":"How does the graphic encapsulation work in Haze ?"},{"location":"Haze/Graphic_encapsulation/#how-does-the-graphic-encapsulation-work-in-haze","text":"The graphic encapsulation exists to allows to change easily the graphic library of the engine. Multiples virtual class exits in this encapsulation those are: - ISprite - ITexture - IText - IAudio - IWindow - IInput - IRect - IColor Each of these class needs to be inherited to allows for full support of a graphic lib. For now Haze support SFML with - SfSprite - SfTexture - SfText - SfAudio - SfWindow - SfInput - SfRect - SfColor","title":"How does the graphic encapsulation work in Haze ?"},{"location":"Haze/How%20to%20use/","text":"Getting Started To get started with the Haze Engine, follow these steps: Include the necessary header files: #include <haze-core> #include <haze-graphics> //Only if you want to display something Create an instance of the Haze::Engine class: Haze::Engine engine; Initialize the engine: engine.init(); Create entities using the Haze::Entity class: Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); Add components to the entities. Here are some examples: //Add a Haze::Position component: entity1->addComponent(new Haze::Position(0, 0)); //Add a Haze::Sprite component: entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); //Add a Haze::Animation component: entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); //Add a Haze::Window component: entity2->addComponent(new Haze::Window(800, 600)); Start the game loop by checking if the engine is open: while (engine.isOpen()) { engine.update(); } Components Component of the haze-core lib are at: [[ComponentCore Technical]] Component of the haze-graphics lib are at: [[ComponentGfx Technical]] Entity Entity are defined at [[Entity Technical]] Example Usage Here's an example of how to use the Haze Engine to create a simple game loop: #include <Haze> int main() { Haze::Engine engine; engine.init(); Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); entity1->addComponent(new Haze::Position(0, 0)); entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); entity2->addComponent(new Haze::Window(800, 600)); while (engine.isOpen()) { engine.update(); } return 0; }","title":"How to use"},{"location":"Haze/How%20to%20use/#getting-started","text":"To get started with the Haze Engine, follow these steps: Include the necessary header files: #include <haze-core> #include <haze-graphics> //Only if you want to display something Create an instance of the Haze::Engine class: Haze::Engine engine; Initialize the engine: engine.init(); Create entities using the Haze::Entity class: Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); Add components to the entities. Here are some examples: //Add a Haze::Position component: entity1->addComponent(new Haze::Position(0, 0)); //Add a Haze::Sprite component: entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); //Add a Haze::Animation component: entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); //Add a Haze::Window component: entity2->addComponent(new Haze::Window(800, 600)); Start the game loop by checking if the engine is open: while (engine.isOpen()) { engine.update(); }","title":"Getting Started"},{"location":"Haze/How%20to%20use/#components","text":"Component of the haze-core lib are at: [[ComponentCore Technical]] Component of the haze-graphics lib are at: [[ComponentGfx Technical]]","title":"Components"},{"location":"Haze/How%20to%20use/#entity","text":"Entity are defined at [[Entity Technical]]","title":"Entity"},{"location":"Haze/How%20to%20use/#example-usage","text":"Here's an example of how to use the Haze Engine to create a simple game loop: #include <Haze> int main() { Haze::Engine engine; engine.init(); Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); entity1->addComponent(new Haze::Position(0, 0)); entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); entity2->addComponent(new Haze::Window(800, 600)); while (engine.isOpen()) { engine.update(); } return 0; }","title":"Example Usage"},{"location":"Haze/Pipeline/","text":"What is a Pipeline in Haze A pipeline is a way to group systems in Haze. It allows to group systems hence allowing to differentiate easily systems that need additional libraries such as SFML from others that don't need it. How to build your Pipeline A pipeline need the inherit from the virtual class IPipeline and only needs to add its systems when constructed. Currently there are two existing pipelines in Haze: GfxPipeline This pipeline gather every system that needs to use SFML and is only used un haze-graphic . CorePipeline This pipeline gather every system that rules basic Haze functionalities like positions, velocity or collisions.","title":"What is a Pipeline in Haze"},{"location":"Haze/Pipeline/#what-is-a-pipeline-in-haze","text":"A pipeline is a way to group systems in Haze. It allows to group systems hence allowing to differentiate easily systems that need additional libraries such as SFML from others that don't need it.","title":"What is a Pipeline in Haze"},{"location":"Haze/Pipeline/#how-to-build-your-pipeline","text":"A pipeline need the inherit from the virtual class IPipeline and only needs to add its systems when constructed. Currently there are two existing pipelines in Haze:","title":"How to build your Pipeline"},{"location":"Haze/Pipeline/#gfxpipeline","text":"This pipeline gather every system that needs to use SFML and is only used un haze-graphic .","title":"GfxPipeline"},{"location":"Haze/Pipeline/#corepipeline","text":"This pipeline gather every system that rules basic Haze functionalities like positions, velocity or collisions.","title":"CorePipeline"},{"location":"Haze/System/","text":"What is a System? In an ECS architecture, a system is a modular component responsible for processing entities that contain specific components. Each system is designed to handle a specific aspect of the game logic, such as rendering, physics, input, or AI. Systems are used to update the state of entities, implement game rules, and perform various operations. How does a system work A system in Haze will iterate trough the ComponentArray to modify the components stored inside. By selecting entities with specific components, a system can act on a selected portion of the entities. Types of Systems and Pipelines In an ECS architecture, various types of systems are commonly used to manage different aspects of a game. We have decided to group these different system types in Pipelines. To lean more about pipeline Pipeline .","title":"What is a System?"},{"location":"Haze/System/#what-is-a-system","text":"In an ECS architecture, a system is a modular component responsible for processing entities that contain specific components. Each system is designed to handle a specific aspect of the game logic, such as rendering, physics, input, or AI. Systems are used to update the state of entities, implement game rules, and perform various operations.","title":"What is a System?"},{"location":"Haze/System/#how-does-a-system-work","text":"A system in Haze will iterate trough the ComponentArray to modify the components stored inside. By selecting entities with specific components, a system can act on a selected portion of the entities.","title":"How does a system work"},{"location":"Haze/System/#types-of-systems-and-pipelines","text":"In an ECS architecture, various types of systems are commonly used to manage different aspects of a game. We have decided to group these different system types in Pipelines. To lean more about pipeline Pipeline .","title":"Types of Systems and Pipelines"},{"location":"Protocol/Component%20Data/","text":"Data used to build a component namespace Haze { struct PositionData { float x; float y; }; struct ScaleData { float x; float y; }; struct VelocityData { float x; float y; }; struct MoveData { float x; float y; }; struct HealthData { int health; }; struct DamageData { int damage; }; struct CollisionData { std::string scene; std::map<std::string, Collision::CollisionInfo> behavior; }; struct HitboxData { std::vector<Hitbox::intRect> hitbox; }; struct LifeTimeData { int lifeTime; }; struct SpriteData { std::string path; }; struct WindowData { int width; int height; }; struct AnimationData { std::vector<Animation::intRect> frames; Animation::AnimationType type; bool direction; double tics; }; struct TextData { std::string text; sf::Color color; }; }","title":"Component Data"},{"location":"Protocol/Component%20Data/#data-used-to-build-a-component","text":"namespace Haze { struct PositionData { float x; float y; }; struct ScaleData { float x; float y; }; struct VelocityData { float x; float y; }; struct MoveData { float x; float y; }; struct HealthData { int health; }; struct DamageData { int damage; }; struct CollisionData { std::string scene; std::map<std::string, Collision::CollisionInfo> behavior; }; struct HitboxData { std::vector<Hitbox::intRect> hitbox; }; struct LifeTimeData { int lifeTime; }; struct SpriteData { std::string path; }; struct WindowData { int width; int height; }; struct AnimationData { std::vector<Animation::intRect> frames; Animation::AnimationType type; bool direction; double tics; }; struct TextData { std::string text; sf::Color color; }; }","title":"Data used to build a component"},{"location":"Protocol/Inputs/","text":"Enum of the inputs enum InputType { KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, NUMKEY_0, NUMKEY_1, NUMKEY_2, NUMKEY_3, NUMKEY_4, NUMKEY_5, NUMKEY_6, NUMKEY_7, NUMKEY_8, NUMKEY_9, KEY_ESC, KEY_ENTER_INPUT, KEY_BACK, KEY_TAB, KEY_SPACE, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_UP_ARROW, KEY_DOWN_ARROW, KEY_LEFT_ARROW, KEY_RIGHT_ARROW, }; enum MouseType { NOTHING, RELEASED, PRESSED };","title":"Inputs"},{"location":"Protocol/Inputs/#enum-of-the-inputs","text":"enum InputType { KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, NUMKEY_0, NUMKEY_1, NUMKEY_2, NUMKEY_3, NUMKEY_4, NUMKEY_5, NUMKEY_6, NUMKEY_7, NUMKEY_8, NUMKEY_9, KEY_ESC, KEY_ENTER_INPUT, KEY_BACK, KEY_TAB, KEY_SPACE, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_UP_ARROW, KEY_DOWN_ARROW, KEY_LEFT_ARROW, KEY_RIGHT_ARROW, }; enum MouseType { NOTHING, RELEASED, PRESSED };","title":"Enum of the inputs"},{"location":"Protocol/Protocol/","text":"Header Each message should have a header with: - A timestamp - An id - A body size ID Client -> Server ID Body Response ID INPUT info_inputs NONE GET_ENTITY id_entity INFO_ENTITY GET_ENTITIES NONE INFO_ENTITIES GET_COMPONENT id_component INFO_COMPONENT ALIVE NONE NONE ID Server -> Client ID Body Response ID CREATE_ENTITY id_entity NONE DELETE_ENTITY id_entity NONE ADD_COMPONENT info_component NONE REMOVE_COMPONENT id_component NONE INFO_COMPONENT info_component NONE INFO_ENTITY info_entity NONE INFO_ENTITIES info_entities NONE DEAD NONE NONE Body The body of a message is just raw data that can be interpreted thanks to the header. info_inputs struct info_inputs { std::vector<InputType> inputsPressed; std::vector<InputType> inputsReleased; MouseType mouseType; int x; int y; }; InputType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] MouseType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] id_entity struct id_entity { int id; }; id_component struct id_component { id_entity id; std::string component; }; info_entity struct info_entity { id_entity id; std::vector<std::string> components; }; info_component struct info_component { std::string component; std::vector<uint8_t> data = std::vector<uint8_t>(128); }; Data at [[Component Data]] info_entities struct info_entities { std::vector<id_entity> id; };","title":"Protocol"},{"location":"Protocol/Protocol/#header","text":"Each message should have a header with: - A timestamp - An id - A body size","title":"Header"},{"location":"Protocol/Protocol/#id-client-server","text":"ID Body Response ID INPUT info_inputs NONE GET_ENTITY id_entity INFO_ENTITY GET_ENTITIES NONE INFO_ENTITIES GET_COMPONENT id_component INFO_COMPONENT ALIVE NONE NONE","title":"ID Client -&gt; Server"},{"location":"Protocol/Protocol/#id-server-client","text":"ID Body Response ID CREATE_ENTITY id_entity NONE DELETE_ENTITY id_entity NONE ADD_COMPONENT info_component NONE REMOVE_COMPONENT id_component NONE INFO_COMPONENT info_component NONE INFO_ENTITY info_entity NONE INFO_ENTITIES info_entities NONE DEAD NONE NONE","title":"ID Server -&gt; Client"},{"location":"Protocol/Protocol/#body","text":"The body of a message is just raw data that can be interpreted thanks to the header. info_inputs struct info_inputs { std::vector<InputType> inputsPressed; std::vector<InputType> inputsReleased; MouseType mouseType; int x; int y; }; InputType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] MouseType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] id_entity struct id_entity { int id; }; id_component struct id_component { id_entity id; std::string component; }; info_entity struct info_entity { id_entity id; std::vector<std::string> components; }; info_component struct info_component { std::string component; std::vector<uint8_t> data = std::vector<uint8_t>(128); }; Data at [[Component Data]] info_entities struct info_entities { std::vector<id_entity> id; };","title":"Body"}]}