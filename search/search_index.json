{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"R-Type Documentation","text":"<p>The R-Type project aims at developing a clone of the classic side-scrolling shoot 'em up arcade game called \"R-Type.\" The project involves creating a server that will start the game, and a client that will be able to display the game. This version of R-Type is multiplayer and the game is developed using a custom engine of our own called Haze.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have met the following requirements:</p> <ul> <li>cmake</li> <li>git</li> </ul>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>To install and launch R-Type, follow these steps:</p> <ol> <li>Clone the github project</li> </ol> <pre><code>git\u00a0clone\u00a0https://github.com/votre-utilisateur/haze-engine.git\n</code></pre> <ol> <li>Download the dependenties</li> </ol> <ol> <li>Create the build directory</li> </ol> <pre><code>cmake -S . -B build\n</code></pre> <ol> <li>Compile the project</li> </ol> <pre><code>cmake --build build\n</code></pre> <ol> <li>Execute the binaries    Server:</li> </ol> <pre><code>./build/r-type-server\n</code></pre> <p>Client:</p> <pre><code>./build/r-type-client\n</code></pre>"},{"location":"#linuxmacos","title":"Linux/MacOS","text":"<pre><code>git clone https://github.com/Microsoft/vcpkg.git\n./vcpkg/bootstrap-vcpkg.sh\n./vcpkg/vcpkg install\n</code></pre>"},{"location":"#windows","title":"Windows","text":"<pre><code>git clone https://github.com/Microsoft/vcpkg.git\n.\\vcpkg\\bootstrap-vcpkg.bat\n.\\vcpkg\\vcpkg install\n</code></pre> <p>[!warning] These commands must be executed at the root of this project</p>"},{"location":"#documentation","title":"\ud83d\udccb Documentation","text":"<p>Haze introduction</p> <p>Game Engine</p> <p>Protocol</p> <p>Rtype</p>"},{"location":"#credits","title":"\ud83d\udc64 Credits","text":"<p>Click on the images below to visit the GitHub profiles of our awesome contributors:</p>"},{"location":"#tools","title":"\ud83d\udee0\ufe0f Tools","text":""},{"location":"Haze/ComponentArray/","title":"ComponentArray","text":""},{"location":"Haze/ComponentArray/#what-is-a-componentarray","title":"What is a ComponentArray","text":"<p>The component array in Haze is where is stored all of the data of the engine. It contains all of the components in a two dimensional sparse array. Each entity being a simple id in this array. (for more details about entity: Entity) Each column in the component array being an entity and each line a component.</p> <p>If an Entity doesn't posses a component this field will simply be null. If this entity have this component, it will contain the pointer to it.</p>"},{"location":"Haze/ComponentCore%20Technical/","title":"ComponentCore Technical","text":""},{"location":"Haze/ComponentCore%20Technical/#component-core","title":"Component core:","text":"<pre><code>#include \"inputs.hpp\"\n\nnamespace Haze\n{\n    class Component;\n    struct Position;\n    struct Scale;\n    struct Velocity;\n    struct Move;\n    struct Health;\n    struct Damage;\n    struct Collision;\n    struct Hitbox;\n    struct LifeTime;\n    struct OnKeyPressed;\n    struct OnKeyReleased;\n    struct OnMousePressed;\n    struct OnMouseReleased;\n    struct Hide;\n}\n</code></pre> <p><pre><code>struct Position : public Component\n{\n    Position(float x, float y) : x(x), y(y) {}\n    float x;\n    float y;\n    std::string getType() const override { return \"Position\"; }\n    void show() const override { std::cout &lt;&lt; \"Position: \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; std::endl; }\n};\n</code></pre> <code>Position</code> is used to set the position of the entity</p> <p><pre><code>struct Scale : public Component\n{\n    Scale(float x, float y) : x(x), y(y) {}\n    float x;\n    float y;\n    std::string getType() const override { return \"Scale\"; }\n    void show() const override { std::cout &lt;&lt; \"Scale: \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; std::endl; }\n};\n</code></pre> <code>Scale</code> sets the scale of the entity. This is applied to the <code>Hitbox</code> </p> <p><pre><code>struct Velocity : public Component\n{\n    Velocity(float x, float y) : x(x), y(y) {}\n    float x;\n    float y;\n    std::string getType() const override { return \"Velocity\"; }\n    void show() const override { std::cout &lt;&lt; \"Velocity: \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; std::endl; }\n};\n</code></pre> <code>Velocity</code> is the movement applied to the entity every frame</p> <p><pre><code>struct Move : public Component\n{\n    Move(float x, float y) : x(x), y(y) {}\n    float x;\n    float y;\n    std::string getType() const override { return \"Move\"; }\n    void show() const override { std::cout &lt;&lt; \"Move: \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; std::endl; }\n};\n</code></pre> <code>Move</code> is a movement applied only once to the entity, it is automatically destroyed after use</p> <p><pre><code>struct Health : public Component\n{\n    Health(int health) : health(health) {}\n    int health;\n    std::string getType() const override { return \"Health\"; }\n    void show() const override { std::cout &lt;&lt; \"Health: \" &lt;&lt; health &lt;&lt; std::endl; }\n};\n</code></pre> <code>Health</code> can be use to setup the health of an entity</p> <p><pre><code>struct Damage : public Component\n{\n    Damage(int damage) : damage(damage) {}\n    int damage;\n    std::string getType() const override { return \"Damage\"; }\n    void show() const override { std::cout &lt;&lt; \"Damage: \" &lt;&lt; damage &lt;&lt; std::endl; }\n};\n</code></pre> <code>Damage</code> can be used to setup the damage of an entity</p> <p><pre><code>struct Collision : public Component\n{\n    enum CollisionType\n    {\n        NONE = 0,\n        LAMBDA = 1,\n        WALL = 2,\n    };\n    struct CollisionInfo\n    {\n        CollisionType type;\n        double tics;\n        std::function&lt;void(int, int)&gt; onCollision = [](int i, int j) {};\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; lastCollision = std::chrono::high_resolution_clock::now();\n    };\n    Collision(std::string scene, std::map&lt;std::string, CollisionInfo&gt; behavior)\n    : scene(scene), behavior(behavior) {}\n\n    std::string scene;\n    std::map&lt;std::string, CollisionInfo&gt; behavior;\n\n    std::string getType() const override { return \"Collision\"; }\n    void show() const override { std::cout &lt;&lt; \"Collision: \" &lt;&lt; scene &lt;&lt; std::endl; }\n};\n</code></pre> <code>Collision</code> is the component that will define the collision behavior of an entity. It takes : - a scene that will be use as an identification tag for a group of entity - and a map of behavior that will define what happens on collision between two entity of certain scene.</p> <p><pre><code>struct Hitbox : public Component\n{\n    struct intRect\n    {\n        int x;\n        int y;\n        int width;\n        int height;\n    };\n    Hitbox(std::vector&lt;intRect&gt; hitbox) : hitbox(hitbox) {}\n    std::vector&lt;intRect&gt; hitbox;\n    std::string getType() const override { return \"Hitbox\"; }\n    void show() const override { std::cout &lt;&lt; \"Hitbox: \" &lt;&lt; std::endl; }\n};\n</code></pre> <code>Hitbox</code> is used to set the hitbox of an entity it is defined as a vector of <code>intRect</code> which allows to have a hitbox composed of multiples rectangles.</p> <p><pre><code>struct LifeTime : public Component\n{\n    LifeTime(int lifeTime) : lifeTime(lifeTime) {}\n    int lifeTime;\n    int tics = 0;\n    std::string getType() const override { return \"LifeTime\"; }\n    void show() const override { std::cout &lt;&lt; \"LifeTime: \" &lt;&lt; lifeTime &lt;&lt; std::endl; }\n};\n</code></pre> <code>LifeTime</code> can be used to set a lifetime limit for an entity This lifetime is expressed in tics.</p> <p><pre><code>struct OnKeyPressed : public Component\n{\n    OnKeyPressed(std::function&lt;void(int, std::vector&lt;InputType&gt;)&gt; callback, size_t player = 0) : callback(callback), player(player) {}\n    std::function&lt;void(int, std::vector&lt;InputType&gt;)&gt; callback;\n    size_t player;\n    std::string getType() const override {return \"OnKeyPressed\";}\n    void show() const override { std::cout &lt;&lt; \"OnKeyPressed\" &lt;&lt; std::endl; }\n};\n</code></pre> <code>OnKeyPressed</code> can be used to set a callback to execute, with as an argument every simultaneous key pressed in the engine. The <code>size_t</code> player is the id of the inputs. The engine can have multiple list of inputs if used as a server.</p> <p><pre><code>struct OnKeyReleased : public Component\n{\n    OnKeyReleased(std::function&lt;void(int, std::vector&lt;InputType&gt;)&gt; callback, size_t player = 0) : callback(callback), player(player) {}\n    std::function&lt;void(int, std::vector&lt;InputType&gt;)&gt; callback;\n    size_t player;\n    std::string getType() const override{return \"OnKeyReleased\";}\n    void show() const override { std::cout &lt;&lt; \"OnKeyReleased\" &lt;&lt; std::endl; }\n};\n</code></pre> <code>OnKeyReleased</code> can be used to set a callback to execute, with as an argument every simultaneous key released in the engine. The <code>size_t</code> player is the id of the inputs. The engine can have multiple list of inputs if used as a server.</p> <p><pre><code>struct OnMousePressed : public Component\n{\n    OnMousePressed(std::function&lt;void(int)&gt; callback, size_t player = 0) : callback(callback), player(player) {}\n    std::function&lt;void(int)&gt; callback;\n    size_t player;\n    std::string getType() const override{return \"OnMousePressed\";}\n    void show() const override { std::cout &lt;&lt; \"OnMousePressed\" &lt;&lt; std::endl; }\n};\n</code></pre> <code>OnMousePressed</code> can be used to set a callback to execute every time the mouse is pressed and is intersecting the hitbox of the entity. The <code>size_t</code> player is the id of the inputs. The engine can have multiple list of inputs if used as a server.</p> <p><pre><code>struct OnMouseReleased : public Component\n{\n    OnMouseReleased(std::function&lt;void(int)&gt; callback, size_t player = 0) : callback(callback), player(player) {}\n    std::function&lt;void(int)&gt; callback;\n    size_t player;\n    std::string getType() const override{return \"OnMouseReleased\";}\n    void show() const override { std::cout &lt;&lt; \"OnMouseReleased\" &lt;&lt; std::endl; }\n};\n</code></pre> <code>OnMouseReleased</code> can be used to set a callback to execute every time the mouse is released and is intersecting the hitbox of the entity. The <code>size_t</code> player is the id of the inputs. The engine can have multiple list of inputs if used as a server.</p> <p><pre><code>struct Hide : public Component\n{\n    Hide() {}\n    std::string getType() const override { return \"Hide\"; }\n    void show() const override { std::cout &lt;&lt; \"Hide\" &lt;&lt; std::endl; }\n};\n</code></pre> <code>Hide</code> is used to disable an entity. When in this state, the entity in not displayed nor can receive inputs or move. </p>"},{"location":"Haze/ComponentGfx%20Technical/","title":"ComponentGfx Technical","text":""},{"location":"Haze/ComponentGfx%20Technical/#component-graphics","title":"Component graphics:","text":"<pre><code>#include \"Component.hpp\"\n#include \"inputs.hpp\"\nnamespace Haze\n{\n    struct Sprite;\n    struct Animation;\n    struct Window;\n    struct HitboxDisplay;\n    struct Text;\n}\n</code></pre> <p><pre><code>struct Sprite : public Component\n{\n    Sprite(std::string path) : path(path)\n    {\n        std::cout &lt;&lt; \"path \" &lt;&lt; path &lt;&lt; std::endl;\n        texture.loadFromFile(path);\n        sprite.setTexture(texture);\n    }\n    std::string path;\n    sf::Sprite sprite;\n    sf::Texture texture;\n    std::string getType() const override{return \"Sprite\";}\n    void show() const override { std::cout &lt;&lt; \"flm\" &lt;&lt; path &lt;&lt; std::endl; }\n};\n</code></pre> <code>Sprite</code> is used to set a sprite with a texture to an entity. It just takes a path for the texture.</p> <p><pre><code>struct Animation : public Component\n{\n    enum AnimationType\n    {\n        LOOP,\n        BOOMERANG,\n        ONCE\n    };\n    struct intRect\n    {\n        int x;\n        int y;\n        int width;\n        int height;\n    };\n    Animation(std::vector&lt;intRect&gt; frames, AnimationType type, bool direction, double tics) : frames(frames), type(type), tics(tics), direction(direction) {}\n    std::vector&lt;intRect&gt; frames;\n    AnimationType type = AnimationType::LOOP;\n    double tics;\n    size_t currentFrame = 0;\n    bool direction = true;\n    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; lastAnimation = std::chrono::high_resolution_clock::now();\n    std::string getType() const override { return \"Animation\"; }\n    void show() const override { std::cout &lt;&lt; \"Animation: \" &lt;&lt; std::endl; }\n};\n</code></pre> <code>Animation</code> is the component that will define how a sprite is animated. It takes: - a vector of <code>IntRect</code> that will define the position and the size of every frame of the animation - an <code>AnimationType</code> that will define id the animation is a <code>LOOP</code>, a <code>BOOMERANG</code> or simply a static image (note that you can still have multiple frames and change by hand the <code>currentFrame</code>) - a direction that will define the direction of the animation (1 for left to right and 2 for right to left). - and a tics that will set the time between the updates of the animation.</p> <p><pre><code>struct Window : public Component\n{\n    Window(int width, int height) : width(width), height(height)\n    {\n        window.create(sf::VideoMode(width, height), \"R-Type\");\n        window.setFramerateLimit(60);\n        window.setKeyRepeatEnabled(true);\n        view.reset(sf::FloatRect(0, 0, width, height));\n        view.setViewport(sf::FloatRect(0, 0, 1.0f, 1.0f));\n        window.setView(view);\n    }\n    int width;\n    int height;\n    sf::RenderWindow window;\n    sf::View view;\n    sf::Event event;\n    std::string getType() const override{return \"Window\";}\n    void show() const override { std::cout &lt;&lt; \"Window: \" &lt;&lt; width &lt;&lt; \", \" &lt;&lt; height &lt;&lt; std::endl; }\n};\n</code></pre> <code>Window</code> is the component that can set the window for your game. A strong advice is that the entity who has the component window doesn't have any other component. </p> <p><pre><code>struct HitboxDisplay : public Component\n{\n    HitboxDisplay()\n    {\n        rect.setFillColor(sf::Color::Transparent);\n        rect.setOutlineColor(sf::Color::Red);\n        rect.setOutlineThickness(5);\n    }\n    sf::Color color = sf::Color::Red;\n    sf::RectangleShape rect;\n\n    std::string getType() const override{return \"HitboxDisplay\";}\n    void show() const override { std::cout &lt;&lt; \"HitboxDisplay: \" &lt;&lt; std::endl; }\n};\n</code></pre> <code>HitboxDisplay</code> is a debug tool to see the <code>Hitbox</code> of your entity</p> <p><pre><code>struct Text : public Component {\n    Text(const std::string &amp;text, sf::Color color, const std::string &amp;fontname = \"arial.ttf\") : text(text), color(color) {\n        font.loadFromFile(\"../assets/fonts/\" + fontname);\n        textObj.setFont(font);\n        textObj.setString(text);\n        textObj.setFillColor(color);\n    }\n    std::string text;\n    sf::Color color;\n    sf::Font font;\n    sf::Text textObj;\n    std::string getType() const override {return \"Text\";}\n    void show() const override { std::cout &lt;&lt; \"Text: \" &lt;&lt; text &lt;&lt; std::endl; }\n};\n</code></pre> <code>Text</code> is used to create a text component to your entity. It takes: - the text you want to display - a color - and a font name</p>"},{"location":"Haze/ECS/","title":"ECS","text":""},{"location":"Haze/ECS/#understanding-the-entity-component-system-ecs-architecture","title":"Understanding the Entity-Component-System (ECS) Architecture","text":"<p>The Entity-Component-System (ECS) architecture is a design pattern commonly used in game development and simulation systems. It separates the game logic into three distinct parts: entities, components, and systems. This separation promotes modularity, flexibility, and performance in managing complex systems.</p>"},{"location":"Haze/ECS/#components","title":"Components","text":"<p>Components are the building blocks of an ECS. They are small, reusable pieces of data that define the attributes or behaviors of an entity. Each component typically contains only the necessary data and functions required for a specific aspect of the entity. For example, in a game, you might have components like:</p> <ul> <li><code>Position</code>: Contains position of the entity</li> <li><code>Sprite</code>: Contains information about the entity's visual representation.</li> <li><code>Scale</code>: Stores information about the entity's scale</li> </ul> <p>Components are often represented as simple data structures and do not contain logic or methods. For more information about components in Haze: ComponentsGfx ComponentsCore</p>"},{"location":"Haze/ECS/#entities","title":"Entities","text":"<p>Entities are the game objects themselves. An entity is essentially a container that groups together one or more components. Entities don't have behavior on their own but gain behavior by having the appropriate components attached. For example, a player character entity might consist of a <code>Position</code>, a <code>Sprite</code>, and an <code>Input</code>.</p> <p>Entities are typically identified by a unique ID or a name to make them easy to reference.</p>"},{"location":"Haze/ECS/#systems","title":"Systems","text":"<p>Systems are responsible for updating and processing entities and their components. Each system has a specific role, such as rendering, physics simulation, or input handling. Systems iterate over the entities that contain the necessary components they are designed to operate on. For example:</p> <ul> <li>The <code>RenderSystem</code> processes entities with <code>SpriteComponent</code> to render them on the screen.</li> <li>The <code>PhysicsSystem</code> handles entities with <code>PhysicsComponent</code> to simulate physics interactions.</li> <li>The <code>InputSystem</code> listens for input events and updates entities with <code>InputComponent</code>.</li> </ul> <p>Systems are crucial for managing the flow of game logic and keeping it organized.</p>"},{"location":"Haze/ECS/#benefits-of-ecs","title":"Benefits of ECS","text":"<ul> <li>Modularity: Components and systems can be added or removed without affecting the rest of the system.</li> <li>Performance: Data locality and cache-friendliness are often optimized in ECS, leading to efficient processing.</li> <li>Scalability: ECS scales well for large and complex systems.</li> <li>Code Reusability: Components are highly reusable, reducing redundant code.</li> </ul>"},{"location":"Haze/Engine%20Technical/","title":"Engine Technical","text":""},{"location":"Haze/Engine%20Technical/#name","title":"Name","text":"<p><code>Haze::Engine</code> - a the main engine class.</p>"},{"location":"Haze/Engine%20Technical/#synopsis","title":"Synopsis","text":"<pre><code>#include \"Entity.hpp\"\n#include \"ComponentList.hpp\"\n#include \"IPipeline.hpp\"\n#include \"protocol.hpp\"\n\nnamespace Haze\n{\n    class Engine\n    {\n    public:\n        Engine();\n        ~Engine();\n        void init();\n        void update();\n        Entity *createEntity();\n        Entity *getEntity(size_t id);\n        void removeEntity(size_t id);\n        void removeEntity(Entity *entity);\n        bool isOpen();\n        void setInfoInputs(info_inputs info, size_t id);\n        ComponentList *getComponentList();\n        std::vector&lt;info_inputs&gt; *getInfoInputs();\n\n    private:\n        std::vector&lt;std::unique_ptr&lt;Entity&gt;&gt; _entities;\n        std::vector&lt;std::unique_ptr&lt;IPipeline&gt;&gt; _pipelines;\n        ComponentList *_componentList;\n        std::vector&lt;info_inputs&gt; _infoInputs;\n    };\n}\n</code></pre>"},{"location":"Haze/Engine%20Technical/#description","title":"Description","text":"<p>The purpose of the <code>Engine</code> class is to encapsulate the entire Haze ecosystem so it can be easily used and extended. </p>"},{"location":"Haze/Engine%20Technical/#methods","title":"Methods","text":"<p><pre><code>void init();\n</code></pre> <code>init</code> is used just after the creation of the engine and and is used to setup everything in the class</p> <p><pre><code>void update();\n</code></pre> <code>update</code> is used to compute one tic of the game. It launches every [[Pipeline]] in the engine</p> <p><pre><code>Entity *createEntity();\n</code></pre> <code>createEntity</code> is used to add an entity to the engine</p> <p><pre><code>Entity *getEntity(size_t id);\n</code></pre> <code>getEntity</code> is used to get an entity from the engine. Returns <code>nullptr</code> if the entity doesn't exits.</p> <p><pre><code>void removeEntity(size_t id);\nvoid removeEntity(Entity *entity);\n</code></pre> <code>removeEntity</code> deletes an entity from the engine</p> <p><pre><code>bool isOpen();\n</code></pre> <code>isOpen</code> tells if the engine is still running</p> <p><pre><code>void setInfoInputs(info_inputs info, size_t id);\n</code></pre> <code>setInfoInputs</code> is used to simulate input into the engine. Useful if the engine is running without <code>haze-graphics</code> in a server. It takes an info_inputs defined at [[Protocol]] and an id which is the number of the player how has sent this input.</p> <p>[!warning] Here id 0 is where is stored the global inputs. It is filled automatically by the <code>pullEvent</code> system from haze-graphics If you are not taking inputs from other players you should not use this method.</p> <p><pre><code>ComponentList *getComponentList();\n</code></pre> <code>getComponentList</code> gives the <code>ComponentList</code> of the program (mainly internal use)*</p> <p><pre><code>std::vector&lt;info_inputs&gt; *getInfoInputs();\n</code></pre> <code>getInfoInputs</code> gives the list of all of the inputs registered in the engine  (mainly internal use)*</p>"},{"location":"Haze/Entity%20Technical/","title":"Entity Technical","text":""},{"location":"Haze/Entity%20Technical/#name","title":"Name","text":"<p><code>Haze::Core</code> - a class representing the entities used in the haze engine. </p>"},{"location":"Haze/Entity%20Technical/#synopsis","title":"Synopsis","text":"<pre><code>#include \"Component.hpp\"\nnamespace Haze {\n    class Entity {\n    public:\n        Entity(ComponentList *componentList, size_t _id);\n        ~Entity();\n        void addComponent(Component *component);\n        void removeComponent(std::string type);\n        Component *getComponent(std::string type);\n        size_t getId() const { return _id; };\n\n    private:\n        size_t _id;\n        ComponentList *_componentList;\n    };\n}\n</code></pre>"},{"location":"Haze/Entity%20Technical/#description","title":"Description","text":"<p>The purpose of the <code>Entity</code> class is to allow the user of Haze to manipulate the components of the system.</p> <p>The concept of <code>Entity</code> in Haze is only an id that points toward a list of components</p>"},{"location":"Haze/Entity%20Technical/#methods","title":"Methods","text":"<p><pre><code>void addComponent(Component *component);\n</code></pre> <code>addComponent</code> is used to add a component to an entity</p> <p><pre><code>void removeComponent(std::string type);\n</code></pre> <code>removeComponent</code> is used to remove a component from an entity</p> <p><pre><code>Component *getComponent(std::string type);\n</code></pre> <code>getComponent</code> is used to get and modify a component of an entity</p> <p><pre><code>size_t getId() const { return _id; };\n</code></pre> <code>getId</code> is used to get the id of an entity</p>"},{"location":"Haze/Getting%20Started/","title":"Getting Started","text":""},{"location":"Haze/Getting%20Started/#ecs","title":"ECS","text":"<p>The Haze engine is a pure ECS with some little tweaks and additions. An ECS architecture has many benefits for a game engine and that is why we chose to use it (benefits described at ECS)</p>"},{"location":"Haze/Getting%20Started/#architecture","title":"Architecture","text":"<p>This is the full architecture of Haze. As you can see we have the basics of an ECS such as Components, Entity and Systems. If you want the technical documentation of these parts of Haze you can learn more at  ComponentsGfx, ComponentsCore, Entities and Systems.</p>"},{"location":"Haze/Getting%20Started/#pipelines","title":"Pipelines","text":"<p>We have also added Pipelines that allows to group systems hence allowing to differentiate easily systems that need additional libraries such as SFML from others that don't need it.</p>"},{"location":"Haze/Getting%20Started/#graphic-encapsulation","title":"Graphic Encapsulation","text":"<p>Graphic encapsulation is also something that we have decided make in our engine. This addition makes it easy to change the graphic library of Haze. These libraries are loaded from dynamic libraries and SFML and SDL2 are currently supported in Haze.</p>"},{"location":"Haze/Getting%20Started/#componentarray-and-entity","title":"ComponentArray and Entity","text":"<p>Finally that entirety of the components of the engine is stored in a sigle class ComponentArray which make the iteration of the component much faster and easier.</p> <p>Entities are just handlers  for the ComponentArray.</p>"},{"location":"Haze/Getting%20Started/#library","title":"Library","text":"<p>Haze is a currently composed of two different static libraries which are:</p>"},{"location":"Haze/Getting%20Started/#haze-core","title":"haze-core","text":"<p>to include with <pre><code>#include &lt;haze-core.hpp&gt;\n</code></pre></p> <p>This library gather everything related to basic engine working such as positions, velocity or collisions. This part of Haze doesn't require any external library to be functional and can be imported in a server.</p>"},{"location":"Haze/Getting%20Started/#haze-graphic","title":"haze-graphic","text":"<p>to include with <pre><code>#include &lt;haze-graphic.hpp&gt;\n</code></pre></p> <p>This library gather everything related to the graphic part of the engine such as displaying, getting inputs or playing audio. This part of Haze require the use of SFML to be functional and cannot be imported in a server nor any system with no SFML install.</p>"},{"location":"Haze/Graphic_encapsulation/","title":"Graphic encapsulation","text":""},{"location":"Haze/Graphic_encapsulation/#how-does-the-graphic-encapsulation-work-in-haze","title":"How does the graphic encapsulation work in Haze ?","text":"<p>The graphic encapsulation exists to allows to change easily the graphic library of the engine.</p> <p>Multiples virtual class exits in this encapsulation those are: - IDisplay - ISprite - ITexture - IText - IAudio - IWindow - IInput - IRect - IColor - IAudioBuffer - IFont</p> <p>Each of these class needs to be inherited to allows for full support of a graphic lib.</p>"},{"location":"Haze/Graphic_encapsulation/#how-do-dynamic-libraries-are-used-in-haze","title":"How do dynamic libraries are used in Haze ?","text":"<p>Since graphic libraries are loaded from dynamic libraries in Haze, it's very easy to add or change graphic libraries. The compilation of these libraries are done using cmake and the <code>.so</code> are put into the <code>Haze/lib</code> directory. These <code>.so</code> files are then loaded into the engine depending of which library you want to use.</p>"},{"location":"Haze/How%20to%20use/","title":"How to use","text":""},{"location":"Haze/How%20to%20use/#getting-started","title":"Getting Started","text":"<p>To get started with the Haze Engine, follow these steps:</p> <ol> <li> <p>Include the necessary header files: <pre><code>#include\u00a0&lt;haze-core&gt;\n#include\u00a0&lt;haze-graphics&gt; //Only if you want to display something\n</code></pre></p> </li> <li> <p>Create an instance of the Haze::Engine class: <pre><code>Haze::Engine\u00a0engine;\n</code></pre></p> </li> <li> <p>Initialize the engine: <pre><code>engine.init();\n</code></pre></p> </li> <li> <p>Create entities using the Haze::Entity class: <pre><code>Haze::Entity\u00a0*entity1\u00a0=\u00a0engine.createEntity();\nHaze::Entity\u00a0*entity2\u00a0=\u00a0engine.createEntity();\n</code></pre></p> </li> <li> <p>Add components to the entities. Here are some examples: <pre><code>//Add a Haze::Position component:\nentity1-&gt;addComponent(new\u00a0Haze::Position(0,\u00a00));\n\n//Add a Haze::Sprite component:\nentity1-&gt;addComponent(new\u00a0Haze::Sprite(\"assets/ship.png\"));\n\n//Add a Haze::Animation component:\nentity1-&gt;addComponent(new\u00a0Haze::Animation(\"assets/r-typesheet30a.gif\",\u00a034,\u00a034,\u00a03,\u00a01));\n\n//Add a Haze::Window component:\nentity2-&gt;addComponent(new\u00a0Haze::Window(800,\u00a0600));\n</code></pre></p> </li> <li> <p>Start the game loop by checking if the engine is open: <pre><code>while\u00a0(engine.isOpen())\n{\n\u00a0\u00a0\u00a0\u00a0engine.update();\n}\n</code></pre></p> </li> </ol>"},{"location":"Haze/How%20to%20use/#components","title":"Components","text":"<p>Component of the haze-core lib are at: [[ComponentCore Technical]]</p> <p>Component of the haze-graphics lib are at: [[ComponentGfx Technical]]</p>"},{"location":"Haze/How%20to%20use/#entity","title":"Entity","text":"<p>Entity are defined at [[Entity Technical]]</p>"},{"location":"Haze/How%20to%20use/#example-usage","title":"Example Usage","text":"<p>Here's an example of how to use the Haze Engine to create a simple game loop:</p> <pre><code>#include &lt;Haze&gt;\n\nint main()\n{\n    Haze::Engine engine;\n    engine.init();\n\n    Haze::Entity *entity1 = engine.createEntity();\n    Haze::Entity *entity2 = engine.createEntity();\n\n    entity1-&gt;addComponent(new Haze::Position(0, 0));\n    entity1-&gt;addComponent(new Haze::Sprite(\"assets/ship.png\"));\n    entity1-&gt;addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1));\n\n    entity2-&gt;addComponent(new Haze::Window(800, 600));\n\n    while (engine.isOpen())\n    {\n        engine.update();\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Haze/Pipeline/","title":"Pipeline","text":""},{"location":"Haze/Pipeline/#what-is-a-pipeline-in-haze","title":"What is a Pipeline in Haze","text":"<p>A pipeline is a way to group systems in Haze. It allows to group systems hence allowing to differentiate easily systems that need additional libraries such as SFML from others that don't need it.</p>"},{"location":"Haze/Pipeline/#how-to-build-your-pipeline","title":"How to build your Pipeline","text":"<p>A pipeline need the inherit from the virtual class <code>IPipeline</code> and only needs to add its systems when constructed.</p> <p>Currently there are two existing pipelines in Haze: </p>"},{"location":"Haze/Pipeline/#gfxpipeline","title":"GfxPipeline","text":"<p>This pipeline gather every system that needs to use SFML and is only used un haze-graphic.</p>"},{"location":"Haze/Pipeline/#corepipeline","title":"CorePipeline","text":"<p>This pipeline gather every system that rules basic Haze functionalities like positions, velocity or collisions.</p>"},{"location":"Haze/System/","title":"System","text":""},{"location":"Haze/System/#what-is-a-system","title":"What is a System?","text":"<p>In an ECS architecture, a system is a modular component responsible for processing entities that contain specific components. Each system is designed to handle a specific aspect of the game logic, such as rendering, physics, input, or AI. Systems are used to update the state of entities, implement game rules, and perform various operations.</p>"},{"location":"Haze/System/#how-does-a-system-work","title":"How does a system work","text":"<p>A system in Haze will iterate trough the ComponentArray to modify the components stored inside. By selecting entities with specific components, a system can act on a selected portion of the entities. </p>"},{"location":"Haze/System/#types-of-systems-and-pipelines","title":"Types of Systems and Pipelines","text":"<p>In an ECS architecture, various types of systems are commonly used to manage different aspects of a game. We have decided to group these different system types in Pipelines. To lean more about pipeline Pipeline.</p>"},{"location":"Protocol/Component%20Data/","title":"Component Data","text":""},{"location":"Protocol/Component%20Data/#data-used-to-build-a-component","title":"Data used to build a component","text":"<pre><code>namespace Haze\n{\n    struct PositionData {\n        float x;\n        float y;\n    };\n\n    struct ScaleData {\n        float x;\n        float y;\n    };\n\n    struct VelocityData {\n        float x;\n        float y;\n    };\n\n    struct MoveData {\n        float x;\n        float y;\n    };\n\n    struct HealthData {\n        int health;\n    };\n\n    struct DamageData {\n        int damage;\n    };\n\n    struct CollisionData {\n        std::string scene;\n        std::map&lt;std::string, Collision::CollisionInfo&gt; behavior;\n    };\n\n    struct HitboxData {\n        std::vector&lt;Hitbox::intRect&gt; hitbox;\n    };\n\n    struct LifeTimeData {\n        int lifeTime;\n    };\n\n    struct SpriteData {\n        std::string path;\n    };\n\n    struct WindowData {\n        int width;\n        int height;\n    };\n\n    struct AnimationData {\n        std::vector&lt;Animation::intRect&gt; frames;\n        Animation::AnimationType type;\n        bool direction;\n        double tics;\n    };\n\n    struct TextData {\n        std::string text;\n        sf::Color color;\n    };\n}\n</code></pre>"},{"location":"Protocol/Inputs/","title":"Inputs","text":""},{"location":"Protocol/Inputs/#enum-of-the-inputs","title":"Enum of the inputs","text":"<pre><code>enum InputType {\n    KEY_A,\n    KEY_B,\n    KEY_C,\n    KEY_D,\n    KEY_E,\n    KEY_F,\n    KEY_G,\n    KEY_H,\n    KEY_I,\n    KEY_J,\n    KEY_K,\n    KEY_L,\n    KEY_M,\n    KEY_N,\n    KEY_O,\n    KEY_P,\n    KEY_Q,\n    KEY_R,\n    KEY_S,\n    KEY_T,\n    KEY_U,\n    KEY_V,\n    KEY_W,\n    KEY_X,\n    KEY_Y,\n    KEY_Z,\n\n    NUMKEY_0,\n    NUMKEY_1,\n    NUMKEY_2,\n    NUMKEY_3,\n    NUMKEY_4,\n    NUMKEY_5,\n    NUMKEY_6,\n    NUMKEY_7,\n    NUMKEY_8,\n    NUMKEY_9,\n\n    KEY_ESC,\n    KEY_ENTER_INPUT,\n    KEY_BACK,\n    KEY_TAB,\n    KEY_SPACE,\n\n    KEY_F1,\n    KEY_F2,\n    KEY_F3,\n    KEY_F4,\n    KEY_F5,\n    KEY_F6,\n    KEY_F7,\n    KEY_F8,\n    KEY_F9,\n    KEY_F10,\n    KEY_F11,\n    KEY_F12,\n\n    KEY_UP_ARROW,\n    KEY_DOWN_ARROW,\n    KEY_LEFT_ARROW,\n    KEY_RIGHT_ARROW,\n};\n</code></pre> <pre><code>enum MouseType {\n    NOTHING,\n    RELEASED,\n    PRESSED\n};\n</code></pre>"},{"location":"Protocol/Protocol/","title":"Protocol","text":""},{"location":"Protocol/Protocol/#header","title":"Header","text":"<p>Each message should have a header with:</p> <ul> <li>A timestamp</li> <li>An id</li> <li>A body size</li> </ul>"},{"location":"Protocol/Protocol/#id-client-server","title":"ID Client -&gt; Server","text":"ID Body Response ID INPUT info_inputs NONE GET_ENTITY id_entity INFO_ENTITY GET_ENTITIES NONE INFO_ENTITIES GET_COMPONENT id_component INFO_COMPONENT ALIVE NONE NONE"},{"location":"Protocol/Protocol/#id-server-client","title":"ID Server -&gt; Client","text":"ID Body Response ID CREATE_ENTITY id_entity NONE DELETE_ENTITY id_entity NONE ADD_COMPONENT info_component NONE REMOVE_COMPONENT id_component NONE INFO_COMPONENT info_component NONE INFO_ENTITY info_entity NONE INFO_ENTITIES info_entities NONE DEAD NONE NONE"},{"location":"Protocol/Protocol/#body","title":"Body","text":"<p>The body of a message is just raw data that can be interpreted thanks to the header.</p> <ul> <li>info_inputs</li> </ul> <pre><code>struct info_inputs {\n    std::vector&lt;InputType&gt; inputsPressed;\n    std::vector&lt;InputType&gt; inputsReleased;\n    MouseType mouseType;\n    int x;\n    int y;\n};\n</code></pre> <p>InputType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] MouseType at [[R-Type/Documentation/Protocol/Inputs|Inputs]]</p> <ul> <li>id_entity</li> </ul> <pre><code>struct id_entity {\n    int id;\n};\n</code></pre> <ul> <li>id_component</li> </ul> <pre><code>struct id_component {\n    id_entity id;\n    std::string component;\n};\n</code></pre> <ul> <li>info_entity</li> </ul> <pre><code>struct info_entity {\n    id_entity id;\n    std::vector&lt;std::string&gt; components;\n};\n</code></pre> <ul> <li>info_component</li> </ul> <pre><code>struct info_component {\n    std::string component;\n    std::vector&lt;uint8_t&gt; data = std::vector&lt;uint8_t&gt;(128);\n};\n</code></pre> <p>Data at [[Component Data]]</p> <ul> <li>info_entities</li> </ul> <pre><code>struct info_entities {\n    std::vector&lt;id_entity&gt; id;\n};\n</code></pre>"},{"location":"Rtype/Create%20Enemy/","title":"Enemy Creation Documentation","text":"<p>This documentation outlines the process of creating enemies for your enemies inside Rtype. You can customize various attributes of your enemies using this data. Store your enemy data in a JSON file and save it in the <code>assets/enemies</code> directory.</p>"},{"location":"Rtype/Create%20Enemy/#enemy-data-structure","title":"Enemy Data Structure","text":"<p>The <code>enemies</code> files should contain the following attributes for each enemy:</p> <ul> <li><code>type</code>: An integer representing the type of enemy.</li> <li><code>damage</code>: An integer representing the damage the enemy deals when he shots. default 0</li> <li><code>life</code>: An integer representing the enemy's life or health points. -1 if immortal. default 1</li> <li><code>shot_type</code>: An integer representing the type of shot the enemy fires.-1 if the enemy does not fire. **default -1   **</li> <li><code>explosion_type</code>: An integer representing the type of explosion the enemy makes when he dies. -1 if the enemy does   not explode. default -1</li> <li><code>path_sprite</code>: A string representing the file path to the enemy's sprite image.</li> <li><code>hitbox</code>: An object specifying the hitbox dimensions with the following properties:<ul> <li><code>x</code>: The x-coordinate of the hitbox's top-left corner.</li> <li><code>y</code>: The y-coordinate of the hitbox's top-left corner.</li> <li><code>width</code>: The width of the hitbox.</li> <li><code>height</code>: The height of the hitbox.</li> </ul> </li> <li> <p><code>fly</code>: A boolean indicating if the enemy can fly. If false, the enemy will be fixed to the ground or the ceiling. *   default false*</p> </li> <li> <p><code>animation_tics</code>: A float representing the time between animation frames. default 0.1</p> </li> <li><code>animation_type</code>: A string representing the type of animation. default \"loop\"</li> <li><code>animation</code>: An object specifying the animation dimensions with the following properties:<ul> <li><code>x</code>: The x-coordinate of the animation's top-left corner.</li> <li><code>y</code>: The y-coordinate of the animation's top-left corner.</li> <li><code>width</code>: The width of the animation.</li> <li><code>height</code>: The height of the animation.</li> </ul> </li> </ul>"},{"location":"Rtype/Create%20Enemy/#heres-an-example-json-data-structure-for-an-enemy","title":"Here's an example JSON data structure for an enemy:","text":"<pre><code>{\n  \"type\": 3,\n  \"damage\": 20,\n  \"life\": 50,\n  \"shot_type\": 2,\n  \"explosion_type\": 2,\n  \"path_sprite\": \"assets/sprites/r-typesheet12.gif\",\n  \"hitbox\": {\n    \"x\": 2,\n    \"y\": 2,\n    \"height\": 14,\n    \"width\": 13\n  },\n  \"fly\": false,\n  \"animation_tics\": 0.1,\n  \"animation_type\": \"loop\",\n  \"animation\": [\n    {\n      \"x\": 0\n      // Additional animation properties...\n    }\n  ]\n}\n</code></pre>"},{"location":"Rtype/Create%20Explosion/","title":"explosion Creation Documentation","text":"<p>This documentation outlines the process of creating explosion for the game.</p>"},{"location":"Rtype/Create%20Explosion/#explosion-data-structure","title":"explosion Data Structure","text":"<p>The <code>explosion</code> files should contain the following attributes for each explosion:</p> <ul> <li><code>type</code>: An integer representing the type of shot.</li> <li> <p><code>path_sprite</code>: A string representing the file path to the shot's sprite image.</p> </li> <li> <p><code>animation_tics</code>: A float representing the time between animation frames. default 0.1</p> </li> <li><code>animation_type</code>: A string representing the type of animation. default \"loop\"<ul> <li><code>\"loop\"</code>: The animation will loop.</li> <li><code>\"boomerang\"</code>: The animation will play forward and then in reverse.</li> <li><code>\"once\"</code>: The animation will play once and then stop.</li> <li><code>\"loop_once\"</code>: The animation will loop until the end and then stop.</li> </ul> </li> <li><code>animation</code>: An object specifying the animation dimensions with the following properties:<ul> <li><code>x</code>: The x-coordinate of the animation's top-left corner.</li> <li><code>y</code>: The y-coordinate of the animation's top-left corner.</li> <li><code>width</code>: The width of the animation.</li> <li><code>height</code>: The height of the animation.</li> </ul> </li> </ul>"},{"location":"Rtype/Create%20Explosion/#heres-an-example-json-data-structure-for-an-explosion","title":"Here's an example JSON data structure for an explosion:","text":"<pre><code>{\n  \"type\": 1,\n  \"path_sprite\": \"assets/sprites/spaceship.gif\",\n  \"animation_tics\": 0.2,\n  \"animation_type\": \"loop_once\",\n  \"animation\": [\n    {\n      \"x\": 0\n      // Additional animation properties...\n    }\n  ]\n}\n</code></pre>"},{"location":"Rtype/Create%20Map/","title":"Creating a Map","text":"<p>This documentation explains how to create a map for Rtype with json data. You can customize various attributes of your map using this data. Ensure that you store your map data in a JSON file and save it in the <code>assets/maps</code> directory.</p>"},{"location":"Rtype/Create%20Map/#json-map-data-structure","title":"JSON Map Data Structure","text":"<p>The JSON map data should include the following attributes:</p> <ul> <li><code>walls</code>: the path to the json file containing the walls data.</li> <li><code>map</code>: An array of objects specifying the map dimensions with the following properties:<ul> <li><code>tile_top</code>: The type of the tile on the top of the map.</li> <li><code>tile_bottom</code>: The type of the tile on the bottom of the map.</li> </ul> </li> </ul>"},{"location":"Rtype/Create%20Map/#heres-an-example-json-data-structure-for-a-map","title":"Here's an example JSON data structure for a map:","text":"<pre><code>{\n  \"walls\": \"assets/json_files/walls/ground.json\",\n  \"map\": [\n    {\n      \"tile_top\": 3,\n      \"tile_bottom\": 3\n    },\n    {\n      \"tile_top\": 1,\n      \"tile_bottom\": 0\n    }\n    ...\n  ]\n}\n</code></pre>"},{"location":"Rtype/Create%20Map/#adding-enemies-to-the-game-map","title":"Adding Enemies to the Game Map","text":"<p>This documentation explains how to add enemies to your game map in Rtype using JSON data. Customize the behavior of each enemy by specifying various attributes. Ensure that you store your enemy data in a JSON file and save it in the <code>assets/enemies</code> directory.</p>"},{"location":"Rtype/Create%20Map/#json-enemy-data-structure","title":"JSON Enemy Data Structure","text":"<p>The JSON enemy data should include the following attributes for each enemy:</p> <ul> <li><code>type</code>: An integer representing the type of enemy. All enemies have a unique type, you can find the type of an enemy   inside the directory <code>assets/enemies</code>.</li> <li><code>x</code>: The x-coordinate of the enemy's initial position, from the position of the tile.</li> <li><code>y</code>: The y-coordinate of the enemy's initial position. 0 is the top of the screen.</li> <li><code>velocity_x</code>: The horizontal velocity of the enemy.</li> <li><code>velocity_y</code>: The vertical velocity of the enemy.</li> <li><code>move</code>: A string indicating the movement pattern of the enemy (\"linear,\" \"circular,\" \"sinusoidal\").</li> <li><code>move_radius</code>: An integer representing the movement radius for circular or sinusoidal movement.</li> <li><code>move_frequency</code>: A floating-point number specifying the movement frequency for sinusoidal movement.</li> <li><code>move_amplitude</code>: An integer indicating the movement amplitude for sinusoidal movement.</li> <li><code>move_time</code>: A floating-point number representing the time duration of the movement pattern.</li> <li><code>move_x</code>: A floating-point number specifying the movement in the x-direction.</li> </ul>"},{"location":"Rtype/Create%20Map/#examples-json-data-for-an-enemy","title":"Examples JSON Data for an Enemy:","text":""},{"location":"Rtype/Create%20Map/#circular-movement","title":"Circular movement","text":"<pre><code>{\n  \"type\": 1,\n  \"x\": 24,\n  \"y\": 200,\n  \"velocity_x\": -2,\n  \"move\": \"circular\",\n  \"move_radius\": 100,\n  \"move_x\": 0.2,\n  \"move_time\": 0.1\n}\n</code></pre>"},{"location":"Rtype/Create%20Map/#sinusoidal-movement","title":"Sinusoidal movement","text":"<pre><code>{\n  \"type\": 2,\n  \"x\": 24,\n  \"y\": 200,\n  \"velocity_x\": -2,\n  \"move\": \"sinusoidal\",\n  \"move_frequency\": 0.1,\n  \"move_amplitude\": 50,\n  \"move_time\": 0.1\n}\n</code></pre>"},{"location":"Rtype/Create%20Map/#linear-movement","title":"Linear movement","text":"<pre><code>{\n  \"type\": 3,\n  \"x\": 24,\n  \"y\": 200,\n  \"velocity_x\": -2,\n  \"move\": \"linear\",\n  \"move_time\": 0.1\n}\n</code></pre>"},{"location":"Rtype/Create%20Shot/","title":"Shot Creation Documentation","text":"<p>This documentation outlines the process of creating shots for the game.</p>"},{"location":"Rtype/Create%20Shot/#shot-data-structure","title":"Shot Data Structure","text":"<p>The <code>shots</code> files should contain the following attributes for each Shot:</p> <ul> <li><code>type</code>: An integer representing the type of shot.</li> <li> <p><code>path_sprite</code>: A string representing the file path to the shot's sprite image.</p> </li> <li> <p><code>animation_tics</code>: A float representing the time between animation frames. default 0.1</p> </li> <li><code>animation_type</code>: A string representing the type of animation. default \"loop\"<ul> <li><code>\"loop\"</code>: The animation will loop.</li> <li><code>\"boomerang\"</code>: The animation will play forward and then in reverse.</li> <li><code>\"once\"</code>: The animation will play once and then stop.</li> <li><code>\"loop_once\"</code>: The animation will loop until the end and then stop.</li> </ul> </li> <li><code>animation</code>: An object specifying the animation dimensions with the following properties:<ul> <li><code>x</code>: The x-coordinate of the animation's top-left corner.</li> <li><code>y</code>: The y-coordinate of the animation's top-left corner.</li> <li><code>width</code>: The width of the animation.</li> <li><code>height</code>: The height of the animation.</li> </ul> </li> </ul>"},{"location":"Rtype/Create%20Shot/#heres-an-example-json-data-structure-for-an-shot","title":"Here's an example JSON data structure for an Shot:","text":"<pre><code>{\n  \"type\": 1,\n  \"path_sprite\": \"assets/sprites/spaceship.gif\",\n  \"animation_tics\": 0.2,\n  \"animation_type\": \"loop_once\",\n  \"animation\": [\n    {\n      \"x\": 0\n      // Additional animation properties...\n    }\n  ]\n}\n</code></pre>"},{"location":"Rtype/Create%20Wall/","title":"wall Creation Documentation","text":"<p>This documentation outlines the process of creating wall for the game.</p>"},{"location":"Rtype/Create%20Wall/#wall-data-structure","title":"wall Data Structure","text":"<p>The <code>wall</code> files should contain the following attributes for each wall:</p> <ul> <li><code>type</code>: An integer representing the type of shot.</li> <li> <p><code>path_sprite</code>: A string representing the file path to the shot's sprite image.</p> </li> <li> <p><code>animation_tics</code>: A float representing the time between animation frames. default 0.1</p> </li> <li><code>animation_type</code>: A string representing the type of animation. default \"loop\"<ul> <li><code>\"loop\"</code>: The animation will loop.</li> <li><code>\"boomerang\"</code>: The animation will play forward and then in reverse.</li> <li><code>\"once\"</code>: The animation will play once and then stop.</li> <li><code>\"loop_once\"</code>: The animation will loop until the end and then stop.</li> </ul> </li> <li><code>animation</code>: An object specifying the animation dimensions with the following properties:<ul> <li><code>x</code>: The x-coordinate of the animation's top-left corner.</li> <li><code>y</code>: The y-coordinate of the animation's top-left corner.</li> <li><code>width</code>: The width of the animation.</li> <li><code>height</code>: The height of the animation.</li> </ul> </li> </ul>"},{"location":"Rtype/Create%20Wall/#heres-an-example-json-data-structure-for-an-wall","title":"Here's an example JSON data structure for an wall:","text":"<pre><code>{\n  \"type\": 1,\n  \"path_sprite\": \"assets/sprites/spaceship.gif\",\n  \"animation_tics\": 0.2,\n  \"animation_type\": \"loop_once\",\n  \"animation\": [\n    {\n      \"x\": 0\n      // Additional animation properties...\n    }\n  ]\n}\n</code></pre>"}]}