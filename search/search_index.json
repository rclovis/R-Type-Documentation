{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"R-Type Documentation The R-Type project aims at developing a clone of the classic side-scrolling shoot 'em up arcade game called \"R-Type.\" The project involves creating a server that will run the game, and a client that will be able to display the game. This version of R-Type is multiplayer and the game is developed using a custom engine of our own called Haze. Prerequisites Before you begin, ensure you have met the following requirements: - SFML - Asio Getting Started To install and launch R-Type, follow these steps: Clone the github project git clone https://github.com/votre-utilisateur/haze-engine.git Create the build directory cmake -S . -B build Compile the project cmake --build build Execute the binaries Server: ./build/r-type-server Client: ./build/r-type-client Doc [[Haze/Haze introduction]] [[Protocol/Protocol]]","title":"R-Type Documentation"},{"location":"#r-type-documentation","text":"The R-Type project aims at developing a clone of the classic side-scrolling shoot 'em up arcade game called \"R-Type.\" The project involves creating a server that will run the game, and a client that will be able to display the game. This version of R-Type is multiplayer and the game is developed using a custom engine of our own called Haze.","title":"R-Type Documentation"},{"location":"#prerequisites","text":"Before you begin, ensure you have met the following requirements: - SFML - Asio","title":"Prerequisites"},{"location":"#getting-started","text":"To install and launch R-Type, follow these steps: Clone the github project git clone https://github.com/votre-utilisateur/haze-engine.git Create the build directory cmake -S . -B build Compile the project cmake --build build Execute the binaries Server: ./build/r-type-server Client: ./build/r-type-client","title":"Getting Started"},{"location":"#doc","text":"[[Haze/Haze introduction]] [[Protocol/Protocol]]","title":"Doc"},{"location":"Haze/Component/","text":"#include \"inputs.hpp\" namespace Haze { class Component { public: virtual ~Component() {} virtual std::string getType() const = 0; virtual void show() const = 0; }; struct Position : public Component { Position(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Position\"; } void show() const override { std::cout << \"Position: \" << x << \", \" << y << std::endl; } }; struct Scale : public Component { Scale(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Scale\"; } void show() const override { std::cout << \"Scale: \" << x << \", \" << y << std::endl; } }; struct Velocity : public Component { Velocity(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Velocity\"; } void show() const override { std::cout << \"Velocity: \" << x << \", \" << y << std::endl; } }; struct Move : public Component { Move(float x, float y) : x(x), y(y) {} float x; float y; std::string getType() const override { return \"Move\"; } void show() const override { std::cout << \"Move: \" << x << \", \" << y << std::endl; } }; struct Health : public Component { Health(int health) : health(health) {} int health; std::string getType() const override { return \"Health\"; } void show() const override { std::cout << \"Health: \" << health << std::endl; } }; struct Damage : public Component { Damage(int damage) : damage(damage) {} int damage; std::string getType() const override { return \"Damage\"; } void show() const override { std::cout << \"Damage: \" << damage << std::endl; } }; struct Collision : public Component { enum CollisionType { NONE = 0, LAMBDA = 1, WALL = 2, }; struct CollisionInfo { CollisionType type; double tics; std::function<void(int, int)> onCollision = [](int i, int j) {}; std::chrono::time_point<std::chrono::high_resolution_clock> lastCollision = std::chrono::high_resolution_clock::now(); }; Collision(std::string scene, std::map<std::string, CollisionInfo> behavior) : scene(scene), behavior(behavior) {} std::string scene; std::map<std::string, CollisionInfo> behavior; std::string getType() const override { return \"Collision\"; } void show() const override { std::cout << \"Collision: \" << scene << std::endl; } }; struct Hitbox : public Component { struct intRect { int x; int y; int width; int height; }; Hitbox(std::vector<intRect> hitbox) : hitbox(hitbox) {} std::vector<intRect> hitbox; std::string getType() const override { return \"Hitbox\"; } void show() const override { std::cout << \"Hitbox: \" << std::endl; } }; struct LifeTime : public Component { LifeTime(int lifeTime) : lifeTime(lifeTime) {} int lifeTime; int tics = 0; std::string getType() const override { return \"LifeTime\"; } void show() const override { std::cout << \"LifeTime: \" << lifeTime << std::endl; } }; struct OnKeyPressed : public Component { OnKeyPressed(std::function<void(int, std::vector<InputType>)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int, std::vector<InputType>)> callback; size_t player; std::string getType() const override {return \"OnKeyPressed\";} void show() const override { std::cout << \"OnKeyPressed\" << std::endl; } }; struct OnKeyReleased : public Component { OnKeyReleased(std::function<void(int, std::vector<InputType>)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int, std::vector<InputType>)> callback; size_t player; std::string getType() const override{return \"OnKeyReleased\";} void show() const override { std::cout << \"OnKeyReleased\" << std::endl; } }; struct OnMousePressed : public Component { OnMousePressed(std::function<void(int)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int)> callback; size_t player; std::string getType() const override{return \"OnMousePressed\";} void show() const override { std::cout << \"OnMousePressed\" << std::endl; } }; struct OnMouseReleased : public Component { OnMouseReleased(std::function<void(int)> callback, size_t player = 0) : callback(callback), player(player) {} std::function<void(int)> callback; size_t player; std::string getType() const override{return \"OnMouseReleased\";} void show() const override { std::cout << \"OnMouseReleased\" << std::endl; } }; }","title":"Component"},{"location":"Haze/ComponentGfx/","text":"#include \"Component.hpp\" #include \"inputs.hpp\" namespace Haze { struct Sprite : public Component { Sprite(std::string path) : path(path) { std::cout << \"path \" << path << std::endl; texture.loadFromFile(path); sprite.setTexture(texture); } std::string path; sf::Sprite sprite; sf::Texture texture; std::string getType() const override{return \"Sprite\";} void show() const override { std::cout << \"flm\" << path << std::endl; } }; struct Animation : public Component { enum AnimationType { LOOP, BOOMERANG, ONCE }; struct intRect { int x; int y; int width; int height; }; Animation(std::vector<intRect> frames, AnimationType type, bool direction, double tics) : frames(frames), type(type), tics(tics), direction(direction) {} std::vector<intRect> frames; AnimationType type = AnimationType::LOOP; double tics; size_t currentFrame = 0; bool direction = true; std::chrono::time_point<std::chrono::high_resolution_clock> lastAnimation = std::chrono::high_resolution_clock::now(); std::string getType() const override { return \"Animation\"; } void show() const override { std::cout << \"Animation: \" << std::endl; } }; struct Window : public Component { Window(int width, int height) : width(width), height(height) { window.create(sf::VideoMode(width, height), \"R-Type\"); window.setFramerateLimit(60); window.setKeyRepeatEnabled(true); view.reset(sf::FloatRect(0, 0, width, height)); view.setViewport(sf::FloatRect(0, 0, 1.0f, 1.0f)); window.setView(view); } int width; int height; sf::RenderWindow window; sf::View view; sf::Event event; std::string getType() const override{return \"Window\";} void show() const override { std::cout << \"Window: \" << width << \", \" << height << std::endl; } }; struct HitboxDisplay : public Component { HitboxDisplay() { rect.setFillColor(sf::Color::Transparent); rect.setOutlineColor(sf::Color::Red); rect.setOutlineThickness(5); } sf::Color color = sf::Color::Red; sf::RectangleShape rect; std::string getType() const override{return \"HitboxDisplay\";} void show() const override { std::cout << \"HitboxDisplay: \" << std::endl; } }; struct Text : public Component { Text(std::string text, sf::Color color) : text(text), color(color) { font.loadFromFile(\"assets/fonts/arial.ttf\"); textObj.setFont(font); textObj.setString(text); textObj.setFillColor(color); } std::string text; sf::Color color; sf::Font font; sf::Text textObj; std::string getType() const override{return \"Text\";} void show() const override { std::cout << \"Text: \" << text << std::endl; } }; }","title":"ComponentGfx"},{"location":"Haze/Engine/","text":"Name Haze::Engine - a the main engine class. Synopsis #include \"Entity.hpp\" #include \"ComponentList.hpp\" #include \"IPipeline.hpp\" #include \"protocol.hpp\" namespace Haze { class Engine { public: Engine(); ~Engine(); void init(); void update(); Entity *createEntity(); Entity *getEntity(size_t id); void removeEntity(size_t id); void removeEntity(Entity *entity); bool isOpen(); void setInfoInputs(info_inputs info, size_t id); ComponentList *getComponentList(); std::vector<info_inputs> *getInfoInputs(); private: std::vector<std::unique_ptr<Entity>> _entities; std::vector<std::unique_ptr<IPipeline>> _pipelines; ComponentList *_componentList; std::vector<info_inputs> _infoInputs; }; } Description The purpose of the Engine class is to encapsulate the entire Haze ecosystem so it can be easily used and extended. Methods void init(); init is used just after the creation of the engine and and is used to setup everything in the class void update(); update is used to compute one tic of the game. It launches every [[Pipelines]] in the engine Entity *createEntity(); createEntity is used to add an entity to the engine Entity *getEntity(size_t id); getEntity is used to get an entity from the engine. Returns nullptr if the entity doesn't exits. void removeEntity(size_t id); void removeEntity(Entity *entity); removeEntity deletes an entity from the engine bool isOpen(); isOpen tells if the engine is still running void setInfoInputs(info_inputs info, size_t id); setInfoInputs is used to simulate input into the engine. Useful if the engine is running without haze-graphics in a server. It takes an info_inputs defined at [[Protocol]] and an id which is the number of the player how has sent this input. [!warning] Here id 0 is where is stored the global inputs. It is filled automatically by the pullEvent system from haze-graphics If you are not taking inputs from other players you should not use this method. ComponentList *getComponentList(); getComponentList gives the ComponentList of the program (mainly internal use) * std::vector<info_inputs> *getInfoInputs(); getInfoInputs gives the list of all of the inputs registered in the engine (mainly internal use) *","title":"Engine"},{"location":"Haze/Engine/#name","text":"Haze::Engine - a the main engine class.","title":"Name"},{"location":"Haze/Engine/#synopsis","text":"#include \"Entity.hpp\" #include \"ComponentList.hpp\" #include \"IPipeline.hpp\" #include \"protocol.hpp\" namespace Haze { class Engine { public: Engine(); ~Engine(); void init(); void update(); Entity *createEntity(); Entity *getEntity(size_t id); void removeEntity(size_t id); void removeEntity(Entity *entity); bool isOpen(); void setInfoInputs(info_inputs info, size_t id); ComponentList *getComponentList(); std::vector<info_inputs> *getInfoInputs(); private: std::vector<std::unique_ptr<Entity>> _entities; std::vector<std::unique_ptr<IPipeline>> _pipelines; ComponentList *_componentList; std::vector<info_inputs> _infoInputs; }; }","title":"Synopsis"},{"location":"Haze/Engine/#description","text":"The purpose of the Engine class is to encapsulate the entire Haze ecosystem so it can be easily used and extended.","title":"Description"},{"location":"Haze/Engine/#methods","text":"void init(); init is used just after the creation of the engine and and is used to setup everything in the class void update(); update is used to compute one tic of the game. It launches every [[Pipelines]] in the engine Entity *createEntity(); createEntity is used to add an entity to the engine Entity *getEntity(size_t id); getEntity is used to get an entity from the engine. Returns nullptr if the entity doesn't exits. void removeEntity(size_t id); void removeEntity(Entity *entity); removeEntity deletes an entity from the engine bool isOpen(); isOpen tells if the engine is still running void setInfoInputs(info_inputs info, size_t id); setInfoInputs is used to simulate input into the engine. Useful if the engine is running without haze-graphics in a server. It takes an info_inputs defined at [[Protocol]] and an id which is the number of the player how has sent this input. [!warning] Here id 0 is where is stored the global inputs. It is filled automatically by the pullEvent system from haze-graphics If you are not taking inputs from other players you should not use this method. ComponentList *getComponentList(); getComponentList gives the ComponentList of the program (mainly internal use) * std::vector<info_inputs> *getInfoInputs(); getInfoInputs gives the list of all of the inputs registered in the engine (mainly internal use) *","title":"Methods"},{"location":"Haze/Entity/","text":"Name Haze::Core - a class representing the entities used in the haze engine. Synopsis #include \"Component.hpp\" namespace Haze { class Entity { public: Entity(ComponentList *componentList, size_t _id); ~Entity(); void addComponent(Component *component); void removeComponent(std::string type); Component *getComponent(std::string type); size_t getId() const { return _id; }; private: size_t _id; ComponentList *_componentList; }; } Description The purpose of the Entity class is to allow the user of Haze to manipulate the components of the system. The concept of Entity in Haze is only an id that points toward a list of components Methods void addComponent(Component *component); addComponent is used to add a component to an entity void removeComponent(std::string type); removeComponent is used to remove a component from an entity Component *getComponent(std::string type); getComponent is used to get and modify a component of an entity size_t getId() const { return _id; }; getId is used to get the id of an entity","title":"Entity"},{"location":"Haze/Entity/#name","text":"Haze::Core - a class representing the entities used in the haze engine.","title":"Name"},{"location":"Haze/Entity/#synopsis","text":"#include \"Component.hpp\" namespace Haze { class Entity { public: Entity(ComponentList *componentList, size_t _id); ~Entity(); void addComponent(Component *component); void removeComponent(std::string type); Component *getComponent(std::string type); size_t getId() const { return _id; }; private: size_t _id; ComponentList *_componentList; }; }","title":"Synopsis"},{"location":"Haze/Entity/#description","text":"The purpose of the Entity class is to allow the user of Haze to manipulate the components of the system. The concept of Entity in Haze is only an id that points toward a list of components","title":"Description"},{"location":"Haze/Entity/#methods","text":"void addComponent(Component *component); addComponent is used to add a component to an entity void removeComponent(std::string type); removeComponent is used to remove a component from an entity Component *getComponent(std::string type); getComponent is used to get and modify a component of an entity size_t getId() const { return _id; }; getId is used to get the id of an entity","title":"Methods"},{"location":"Haze/Haze%20introduction/","text":"Getting Started To get started with the Haze Engine, follow these steps: Include the necessary header files: #include <haze-core> #include <haze-graphics> //Only if you want to display something Create an instance of the Haze::Engine class: Haze::Engine engine; Initialize the engine: engine.init(); Create entities using the Haze::Entity class: Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); Add components to the entities. Here are some examples: //Add a Haze::Position component: entity1->addComponent(new Haze::Position(0, 0)); //Add a Haze::Sprite component: entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); //Add a Haze::Animation component: entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); //Add a Haze::Window component: entity2->addComponent(new Haze::Window(800, 600)); Start the game loop by checking if the engine is open: while (engine.isOpen()) { engine.update(); } Components Component of the haze-core lib are at: [[Component]] Component of the haze-graphics lib are at: [[ComponentGfx]] Example Usage Here's an example of how to use the Haze Engine to create a simple game loop: #include <Haze> int main() { Haze::Engine engine; engine.init(); Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); entity1->addComponent(new Haze::Position(0, 0)); entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); entity2->addComponent(new Haze::Window(800, 600)); while (engine.isOpen()) { engine.update(); } return 0; }","title":"Haze introduction"},{"location":"Haze/Haze%20introduction/#getting-started","text":"To get started with the Haze Engine, follow these steps: Include the necessary header files: #include <haze-core> #include <haze-graphics> //Only if you want to display something Create an instance of the Haze::Engine class: Haze::Engine engine; Initialize the engine: engine.init(); Create entities using the Haze::Entity class: Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); Add components to the entities. Here are some examples: //Add a Haze::Position component: entity1->addComponent(new Haze::Position(0, 0)); //Add a Haze::Sprite component: entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); //Add a Haze::Animation component: entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); //Add a Haze::Window component: entity2->addComponent(new Haze::Window(800, 600)); Start the game loop by checking if the engine is open: while (engine.isOpen()) { engine.update(); }","title":"Getting Started"},{"location":"Haze/Haze%20introduction/#components","text":"Component of the haze-core lib are at: [[Component]] Component of the haze-graphics lib are at: [[ComponentGfx]]","title":"Components"},{"location":"Haze/Haze%20introduction/#example-usage","text":"Here's an example of how to use the Haze Engine to create a simple game loop: #include <Haze> int main() { Haze::Engine engine; engine.init(); Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); entity1->addComponent(new Haze::Position(0, 0)); entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); entity2->addComponent(new Haze::Window(800, 600)); while (engine.isOpen()) { engine.update(); } return 0; }","title":"Example Usage"},{"location":"Haze/Pipelines/","text":"","title":"Pipelines"},{"location":"Protocol/Component%20Data/","text":"Data used to build a component namespace Haze { struct PositionData { float x; float y; }; struct ScaleData { float x; float y; }; struct VelocityData { float x; float y; }; struct MoveData { float x; float y; }; struct HealthData { int health; }; struct DamageData { int damage; }; struct CollisionData { std::string scene; std::map<std::string, Collision::CollisionInfo> behavior; }; struct HitboxData { std::vector<Hitbox::intRect> hitbox; }; struct LifeTimeData { int lifeTime; }; struct SpriteData { std::string path; }; struct WindowData { int width; int height; }; struct AnimationData { std::vector<Animation::intRect> frames; Animation::AnimationType type; bool direction; double tics; }; struct TextData { std::string text; sf::Color color; }; }","title":"Component Data"},{"location":"Protocol/Component%20Data/#data-used-to-build-a-component","text":"namespace Haze { struct PositionData { float x; float y; }; struct ScaleData { float x; float y; }; struct VelocityData { float x; float y; }; struct MoveData { float x; float y; }; struct HealthData { int health; }; struct DamageData { int damage; }; struct CollisionData { std::string scene; std::map<std::string, Collision::CollisionInfo> behavior; }; struct HitboxData { std::vector<Hitbox::intRect> hitbox; }; struct LifeTimeData { int lifeTime; }; struct SpriteData { std::string path; }; struct WindowData { int width; int height; }; struct AnimationData { std::vector<Animation::intRect> frames; Animation::AnimationType type; bool direction; double tics; }; struct TextData { std::string text; sf::Color color; }; }","title":"Data used to build a component"},{"location":"Protocol/Inputs/","text":"Enum of the inputs enum InputType { KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, NUMKEY_0, NUMKEY_1, NUMKEY_2, NUMKEY_3, NUMKEY_4, NUMKEY_5, NUMKEY_6, NUMKEY_7, NUMKEY_8, NUMKEY_9, KEY_ESC, KEY_ENTER_INPUT, KEY_BACK, KEY_TAB, KEY_SPACE, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_UP_ARROW, KEY_DOWN_ARROW, KEY_LEFT_ARROW, KEY_RIGHT_ARROW, }; enum MouseType { NOTHING, RELEASED, PRESSED };","title":"Inputs"},{"location":"Protocol/Inputs/#enum-of-the-inputs","text":"enum InputType { KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, NUMKEY_0, NUMKEY_1, NUMKEY_2, NUMKEY_3, NUMKEY_4, NUMKEY_5, NUMKEY_6, NUMKEY_7, NUMKEY_8, NUMKEY_9, KEY_ESC, KEY_ENTER_INPUT, KEY_BACK, KEY_TAB, KEY_SPACE, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_UP_ARROW, KEY_DOWN_ARROW, KEY_LEFT_ARROW, KEY_RIGHT_ARROW, }; enum MouseType { NOTHING, RELEASED, PRESSED };","title":"Enum of the inputs"},{"location":"Protocol/Protocol/","text":"Header Each message should have a header with: - A timestamp - An id - A body size ID Client -> Server ID Body Response ID INPUT info_inputs NONE GET_ENTITY id_entity INFO_ENTITY GET_ENTITIES NONE INFO_ENTITIES GET_COMPONENT id_component INFO_COMPONENT ALIVE NONE NONE ID Server -> Client ID Body Response ID CREATE_ENTITY id_entity NONE DELETE_ENTITY id_entity NONE ADD_COMPONENT info_component NONE REMOVE_COMPONENT id_component NONE INFO_COMPONENT info_component NONE INFO_ENTITY info_entity NONE INFO_ENTITIES info_entities NONE DEAD NONE NONE Body The body of a message is just raw data that can be interpreted thanks to the header. info_inputs struct info_inputs { std::vector<InputType> inputsPressed; std::vector<InputType> inputsReleased; MouseType mouseType; int x; int y; }; InputType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] MouseType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] id_entity struct id_entity { int id; }; id_component struct id_component { id_entity id; std::string component; }; info_entity struct info_entity { id_entity id; std::vector<std::string> components; }; info_component struct info_component { std::string component; std::vector<uint8_t> data = std::vector<uint8_t>(128); }; Data at [[Component Data]] info_entities struct info_entities { std::vector<id_entity> id; };","title":"Protocol"},{"location":"Protocol/Protocol/#header","text":"Each message should have a header with: - A timestamp - An id - A body size","title":"Header"},{"location":"Protocol/Protocol/#id-client-server","text":"ID Body Response ID INPUT info_inputs NONE GET_ENTITY id_entity INFO_ENTITY GET_ENTITIES NONE INFO_ENTITIES GET_COMPONENT id_component INFO_COMPONENT ALIVE NONE NONE","title":"ID Client -&gt; Server"},{"location":"Protocol/Protocol/#id-server-client","text":"ID Body Response ID CREATE_ENTITY id_entity NONE DELETE_ENTITY id_entity NONE ADD_COMPONENT info_component NONE REMOVE_COMPONENT id_component NONE INFO_COMPONENT info_component NONE INFO_ENTITY info_entity NONE INFO_ENTITIES info_entities NONE DEAD NONE NONE","title":"ID Server -&gt; Client"},{"location":"Protocol/Protocol/#body","text":"The body of a message is just raw data that can be interpreted thanks to the header. info_inputs struct info_inputs { std::vector<InputType> inputsPressed; std::vector<InputType> inputsReleased; MouseType mouseType; int x; int y; }; InputType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] MouseType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] id_entity struct id_entity { int id; }; id_component struct id_component { id_entity id; std::string component; }; info_entity struct info_entity { id_entity id; std::vector<std::string> components; }; info_component struct info_component { std::string component; std::vector<uint8_t> data = std::vector<uint8_t>(128); }; Data at [[Component Data]] info_entities struct info_entities { std::vector<id_entity> id; };","title":"Body"}]}