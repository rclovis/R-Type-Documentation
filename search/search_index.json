{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"R-Type Documentation The R-Type project aims at developing a clone of the classic side-scrolling shoot 'em up arcade game called \"R-Type.\" The project involves creating a server that will run the game, and a client that will be able to display the game. This version of R-Type is multiplayer and the game is developed using a custom engine of our own called Haze. Prerequisites Before you begin, ensure you have met the following requirements: - SFML - Asio Getting Started To install and launch R-Type, follow these steps: Clone the github project git clone https://github.com/votre-utilisateur/haze-engine.git Create the build directory cmake -S . -B build Compile the project cmake --build build Execute the binaries Server: ./build/r-type-server Client: ./build/r-type-client Doc [[Haze introduction]] [[Protocol]]","title":"R-Type Documentation"},{"location":"#r-type-documentation","text":"The R-Type project aims at developing a clone of the classic side-scrolling shoot 'em up arcade game called \"R-Type.\" The project involves creating a server that will run the game, and a client that will be able to display the game. This version of R-Type is multiplayer and the game is developed using a custom engine of our own called Haze.","title":"R-Type Documentation"},{"location":"#prerequisites","text":"Before you begin, ensure you have met the following requirements: - SFML - Asio","title":"Prerequisites"},{"location":"#getting-started","text":"To install and launch R-Type, follow these steps: Clone the github project git clone https://github.com/votre-utilisateur/haze-engine.git Create the build directory cmake -S . -B build Compile the project cmake --build build Execute the binaries Server: ./build/r-type-server Client: ./build/r-type-client","title":"Getting Started"},{"location":"#doc","text":"[[Haze introduction]] [[Protocol]]","title":"Doc"},{"location":"Haze/Entity/","text":"Name Haze::Core - a class representing the entities used in the haze engine. Synopsys #include \"Component.hpp\" namespace Haze { class Entity { public: Entity(); ~Entity(); void setComponentList(ComponentList *componentList); void setId(size_t id); void addComponent(Component *component); void removeComponent(std::string type); Component *getComponent(std::string type); void showComponents(); size_t getId() const { return _id; }; private: size_t _id; ComponentList *_componentList; }; } Description Their purpose of the Entity class is to encapsulate a vector of Components that will define an element in the engine.","title":"Entity"},{"location":"Haze/Entity/#name","text":"Haze::Core - a class representing the entities used in the haze engine.","title":"Name"},{"location":"Haze/Entity/#synopsys","text":"#include \"Component.hpp\" namespace Haze { class Entity { public: Entity(); ~Entity(); void setComponentList(ComponentList *componentList); void setId(size_t id); void addComponent(Component *component); void removeComponent(std::string type); Component *getComponent(std::string type); void showComponents(); size_t getId() const { return _id; }; private: size_t _id; ComponentList *_componentList; }; }","title":"Synopsys"},{"location":"Haze/Entity/#description","text":"Their purpose of the Entity class is to encapsulate a vector of Components that will define an element in the engine.","title":"Description"},{"location":"Haze/Haze%20introduction/","text":"To get started with the Haze Engine, follow these steps: Include the necessary header files: #include <haze-core> #include <haze-graphics> //Only if you want to display something Create an instance of the Haze::Engine class: Haze::Engine engine; Initialize the engine: engine.init(); Create entities using the Haze::Entity class: Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); Add components to the entities. Here are some examples: //Add a Haze::Position component: entity1->addComponent(new Haze::Position(0, 0)); //Add a Haze::Sprite component: entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); //Add a Haze::Animation component: entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); //Add a Haze::Window component: entity2->addComponent(new Haze::Window(800, 600)); Start the game loop by checking if the engine is open: while (engine.isOpen()) { engine.update(); } Components Example Usage Here's an example of how to use the Haze Engine to create a simple game loop: #include <Haze> int main() { Haze::Engine engine; engine.init(); Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); entity1->addComponent(new Haze::Position(0, 0)); entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); entity2->addComponent(new Haze::Window(800, 600)); while (engine.isOpen()) { engine.update(); } return 0; }","title":"Haze introduction"},{"location":"Haze/Haze%20introduction/#components","text":"","title":"Components"},{"location":"Haze/Haze%20introduction/#example-usage","text":"Here's an example of how to use the Haze Engine to create a simple game loop: #include <Haze> int main() { Haze::Engine engine; engine.init(); Haze::Entity *entity1 = engine.createEntity(); Haze::Entity *entity2 = engine.createEntity(); entity1->addComponent(new Haze::Position(0, 0)); entity1->addComponent(new Haze::Sprite(\"assets/ship.png\")); entity1->addComponent(new Haze::Animation(\"assets/r-typesheet30a.gif\", 34, 34, 3, 1)); entity2->addComponent(new Haze::Window(800, 600)); while (engine.isOpen()) { engine.update(); } return 0; }","title":"Example Usage"},{"location":"Protocol/Component%20Data/","text":"Data used to build a component namespace Haze { struct PositionData { float x; float y; }; struct ScaleData { float x; float y; }; struct VelocityData { float x; float y; }; struct MoveData { float x; float y; }; struct HealthData { int health; }; struct DamageData { int damage; }; struct CollisionData { std::string scene; std::map<std::string, Collision::CollisionInfo> behavior; }; struct HitboxData { std::vector<Hitbox::intRect> hitbox; }; struct LifeTimeData { int lifeTime; }; struct SpriteData { std::string path; }; struct WindowData { int width; int height; }; struct AnimationData { std::vector<Animation::intRect> frames; Animation::AnimationType type; bool direction; double tics; }; struct TextData { std::string text; sf::Color color; }; }","title":"Component Data"},{"location":"Protocol/Component%20Data/#data-used-to-build-a-component","text":"namespace Haze { struct PositionData { float x; float y; }; struct ScaleData { float x; float y; }; struct VelocityData { float x; float y; }; struct MoveData { float x; float y; }; struct HealthData { int health; }; struct DamageData { int damage; }; struct CollisionData { std::string scene; std::map<std::string, Collision::CollisionInfo> behavior; }; struct HitboxData { std::vector<Hitbox::intRect> hitbox; }; struct LifeTimeData { int lifeTime; }; struct SpriteData { std::string path; }; struct WindowData { int width; int height; }; struct AnimationData { std::vector<Animation::intRect> frames; Animation::AnimationType type; bool direction; double tics; }; struct TextData { std::string text; sf::Color color; }; }","title":"Data used to build a component"},{"location":"Protocol/Inputs/","text":"Enum of the inputs enum InputType { KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, NUMKEY_0, NUMKEY_1, NUMKEY_2, NUMKEY_3, NUMKEY_4, NUMKEY_5, NUMKEY_6, NUMKEY_7, NUMKEY_8, NUMKEY_9, KEY_ESC, KEY_ENTER_INPUT, KEY_BACK, KEY_TAB, KEY_SPACE, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_UP_ARROW, KEY_DOWN_ARROW, KEY_LEFT_ARROW, KEY_RIGHT_ARROW, NOTHING }; enum MouseType { NOTHING, RELEASED, PRESSED };","title":"Inputs"},{"location":"Protocol/Inputs/#enum-of-the-inputs","text":"enum InputType { KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, NUMKEY_0, NUMKEY_1, NUMKEY_2, NUMKEY_3, NUMKEY_4, NUMKEY_5, NUMKEY_6, NUMKEY_7, NUMKEY_8, NUMKEY_9, KEY_ESC, KEY_ENTER_INPUT, KEY_BACK, KEY_TAB, KEY_SPACE, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_UP_ARROW, KEY_DOWN_ARROW, KEY_LEFT_ARROW, KEY_RIGHT_ARROW, NOTHING }; enum MouseType { NOTHING, RELEASED, PRESSED };","title":"Enum of the inputs"},{"location":"Protocol/Protocol/","text":"Header Each message should have a header with: - A timestamp - An id - A body size ID Client -> Server ID Body Response ID INPUT info_inputs NONE GET_ENTITY id_entity INFO_ENTITY GET_ENTITIES NONE INFO_ENTITIES GET_COMPONENT id_component INFO_COMPONENT ALIVE NONE NONE ID Server -> Client ID Body Response ID CREATE_ENTITY id_entity NONE DELETE_ENTITY id_entity NONE ADD_COMPONENT info_component NONE REMOVE_COMPONENT id_component NONE INFO_COMPONENT info_component NONE INFO_ENTITY info_entity NONE INFO_ENTITIES info_entities NONE DEAD NONE NONE Body The body of a message is just raw data that can be interpreted thanks to the header. info_inputs struct info_inputs { std::vector<InputType> inputsPressed; std::vector<InputType> inputsReleased; MouseType mouseType; int x; int y; }; InputType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] MouseType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] id_entity struct id_entity { int id; }; id_component struct id_component { id_entity id; std::string component; }; info_entity struct info_entity { id_entity id; std::vector<std::string> components; }; info_component struct info_component { std::string component; std::vector<uint8_t> data = std::vector<uint8_t>(128); }; Data at [[Component Data]] info_entities struct info_entities { std::vector<id_entity> id; };","title":"Protocol"},{"location":"Protocol/Protocol/#header","text":"Each message should have a header with: - A timestamp - An id - A body size","title":"Header"},{"location":"Protocol/Protocol/#id-client-server","text":"ID Body Response ID INPUT info_inputs NONE GET_ENTITY id_entity INFO_ENTITY GET_ENTITIES NONE INFO_ENTITIES GET_COMPONENT id_component INFO_COMPONENT ALIVE NONE NONE","title":"ID Client -&gt; Server"},{"location":"Protocol/Protocol/#id-server-client","text":"ID Body Response ID CREATE_ENTITY id_entity NONE DELETE_ENTITY id_entity NONE ADD_COMPONENT info_component NONE REMOVE_COMPONENT id_component NONE INFO_COMPONENT info_component NONE INFO_ENTITY info_entity NONE INFO_ENTITIES info_entities NONE DEAD NONE NONE","title":"ID Server -&gt; Client"},{"location":"Protocol/Protocol/#body","text":"The body of a message is just raw data that can be interpreted thanks to the header. info_inputs struct info_inputs { std::vector<InputType> inputsPressed; std::vector<InputType> inputsReleased; MouseType mouseType; int x; int y; }; InputType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] MouseType at [[R-Type/Documentation/Protocol/Inputs|Inputs]] id_entity struct id_entity { int id; }; id_component struct id_component { id_entity id; std::string component; }; info_entity struct info_entity { id_entity id; std::vector<std::string> components; }; info_component struct info_component { std::string component; std::vector<uint8_t> data = std::vector<uint8_t>(128); }; Data at [[Component Data]] info_entities struct info_entities { std::vector<id_entity> id; };","title":"Body"}]}